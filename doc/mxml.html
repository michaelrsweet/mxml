<!DOCTYPE html>
<html lang="en-US">
<head>
<title>Mini-XML 4.0 Programming Manual</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="generator" content="codedoc v3.8">
<meta name="author" content="Michael R Sweet">
<meta name="language" content="en-US">
<meta name="copyright" content="Copyright © 2003-2025, All Rights Reserved.">
<meta name="version" content="4.0">
<style type="text/css"><!--
body {
  background: white;
  color: black;
  font-family: sans-serif;
  font-size: 12pt;
}
a {
  color: black;
}
a:link, a:visited {
  color: #00f;
}
a:link:hover, a:visited:hover, a:active {
  color: #c0c;
}
body, p, h1, h2, h3, h4, h5, h6 {
  font-family: sans-serif;
  line-height: 1.4;
}
h1, h2, h3, h4, h5, h6 {
  font-weight: bold;
  page-break-inside: avoid;
}
h1 {
  font-size: 250%;
  margin: 0;
}
h2 {
  font-size: 250%;
  margin-top: 1.5em;
}
h3 {
  font-size: 200%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
h4 {
  font-size: 150%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
h5 {
  font-size: 125%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
h6 {
  font-size: 110%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
img.title {
  width: 256px;
}
div.header h1, div.header p {
  text-align: center;
}
div.contents, div.body, div.footer {
  page-break-before: always;
}
.class, .enumeration, .function, .struct, .typedef, .union {
  border-bottom: solid 2px gray;
}
.description {
  margin-top: 0.5em;
}
.function {
  margin-bottom: 0;
}
blockquote {
  border: solid thin gray;
  box-shadow: 3px 3px 5px rgba(127,127,127,0.25);
  margin: 1em 0;
  padding: 10px;
  page-break-inside: avoid;
}
blockquote :first-child {
  margin-top: 0;
}
blockquote :first-child {
  margin-bottom: 0;
}
p code, li code, p.code, pre, ul.code li {
  font-family: monospace;
  hyphens: manual;
  -webkit-hyphens: manual;
}
p.code, pre, ul.code li {
  background: rgba(127,127,127,0.25);
  border: thin dotted gray;
  padding: 10px;
  page-break-inside: avoid;
}
pre {
  white-space: pre-wrap;
}
a:link, a:visited {
  text-decoration: none;
}
span.info {
  background: black;
  border: solid thin black;
  color: white;
  font-size: 80%;
  font-style: italic;
  font-weight: bold;
  white-space: nowrap;
}
h1 span.info, h2 span.info, h3 span.info, h4 span.info {
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  float: right;
  padding: 3px 6px;
}
ul.code, ul.contents, ul.subcontents {
  list-style-type: none;
  margin: 0;
  padding-left: 0;
}
ul.code li {
  margin: 0;
}
ul.contents > li {
  margin-top: 1em;
}
ul.contents li ul.code, ul.contents li ul.subcontents {
  padding-left: 2em;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
}
td {
  border: solid 1px gray;
  padding: 5px 10px;
  vertical-align: top;
}
td.left {
  text-align: left;
}
td.center {
  text-align: center;
}
td.right {
  text-align: right;
}
th {
  border-bottom: solid 2px gray;
  padding: 1px 5px;
  text-align: center;
  vertical-align: bottom;
}
tr:nth-child(even) {
  background: rgba(127,127,127,0.25);
}
table.list {
  border-collapse: collapse;
  width: 100%;
}
table.list th {
  border-bottom: none;
  border-right: 2px solid gray;
  font-family: monospace;
  font-weight: normal;
  padding: 5px 10px 5px 2px;
  text-align: right;
  vertical-align: top;
}
table.list td {
  border: none;
  padding: 5px 2px 5px 10px;
  text-align: left;
  vertical-align: top;
}
h2.title, h3.title {
  border-bottom: solid 2px gray;
}
/* Syntax highlighting */
span.comment {
  color: darkgreen;
}
span.directive {
  color: red;
}
span.number {
  color: brown;
}
span.reserved {
  color: blue;
}
span.string {
  color: magenta;
}
/* Dark mode overrides */
@media (prefers-color-scheme: dark) {
  body {
    background: black;
    color: #ccc;
  }
  a {
    color: #ccc;
  }
  a:link, a:visited {
    color: #66f;
  }
  a:link:hover, a:visited:hover, a:active {
    color: #f06;
  }
}
/* Show contents on left side in web browser */
@media screen and (min-width: 800px) {
  div.contents {
    border-right: solid thin gray;
    bottom: 0px;
    box-shadow: 3px 3px 5px rgba(127,127,127,0.5);
    font-size: 10pt;
    left: 0px;
    overflow: scroll;
    padding: 1%;
    position: fixed;
    top: 0px;
    width: 18%;
  }
  div.contents h2.title {
    margin-top: 0px;
  }
  div.header, div.body, div.footer {
    margin-left: 20%;
    padding: 1% 2%;
  }
}
/* Center title page content vertically */
@media print {
  div.header {
    padding-top: 33%;
  }
}
--></style>
</head>
<body>
<div class="header">
<p><img class="title" src="mxml-cover.png"></p>
<h1 class="title">Mini-XML 4.0 Programming Manual</h1>
<p>Michael R Sweet</p>
<p>Copyright © 2003-2025, All Rights Reserved.</p>
</div>
<div class="contents">
<h2 class="title">Contents</h2>
<ul class="contents">
<li><a href="#introduction">Introduction</a><ul class="subcontents">
<li><a href="#history">History</a></li>
<li><a href="#resources">Resources</a></li>
<li><a href="#legal-stuff">Legal Stuff</a></li>
</ul></li>
<li><a href="#using-mini-xml">Using Mini-XML</a><ul class="subcontents">
<li><a href="#api-basics">API Basics</a></li>
<li><a href="#loading-an-xml-file">Loading an XML File</a></li>
<li><a href="#finding-nodes">Finding Nodes</a></li>
<li><a href="#getting-the-values-from-nodes">Getting the Value(s) from Nodes</a></li>
<li><a href="#saving-an-xml-file">Saving an XML File</a></li>
<li><a href="#freeing-memory">Freeing Memory</a></li>
</ul></li>
<li><a href="#creating-new-xml-documents">Creating New XML Documents</a><ul class="subcontents">
<li><a href="#element-nodes">Element Nodes</a></li>
<li><a href="#cdata-nodes">CDATA Nodes</a></li>
<li><a href="#comment-nodes">Comment Nodes</a></li>
<li><a href="#processing-instruction-nodes">Processing Instruction Nodes</a></li>
<li><a href="#integer-nodes">Integer Nodes</a></li>
<li><a href="#opaque-string-nodes">Opaque String Nodes</a></li>
<li><a href="#real-number-nodes">Real Number Nodes</a></li>
<li><a href="#text-nodes">Text Nodes</a></li>
</ul></li>
<li><a href="#iterating-and-indexing-the-tree">Iterating and Indexing the Tree</a><ul class="subcontents">
<li><a href="#iterating-nodes">Iterating Nodes</a></li>
<li><a href="#indexing">Indexing</a></li>
</ul></li>
<li><a href="#advanced-usage">Advanced Usage</a><ul class="subcontents">
<li><a href="#custom-data-types">Custom Data Types</a></li>
<li><a href="#sax-stream-loading-of-documents">SAX (Stream) Loading of Documents</a></li>
<li><a href="#user-data">User Data</a></li>
<li><a href="#memory-management">Memory Management</a></li>
</ul></li>
<li><a href="#migrating-from-mini-xml-v3.x">Migrating from Mini-XML v3.x</a></li>
<li><a href="#FUNCTIONS">Functions</a><ul class="subcontents">
<li><a href="#mxmlAdd">mxmlAdd</a></li>
<li><a href="#mxmlDelete">mxmlDelete</a></li>
<li><a href="#mxmlElementClearAttr">mxmlElementClearAttr</a></li>
<li><a href="#mxmlElementGetAttr">mxmlElementGetAttr</a></li>
<li><a href="#mxmlElementGetAttrByIndex">mxmlElementGetAttrByIndex</a></li>
<li><a href="#mxmlElementGetAttrCount">mxmlElementGetAttrCount</a></li>
<li><a href="#mxmlElementSetAttr">mxmlElementSetAttr</a></li>
<li><a href="#mxmlElementSetAttrf">mxmlElementSetAttrf</a></li>
<li><a href="#mxmlFindElement">mxmlFindElement</a></li>
<li><a href="#mxmlFindPath">mxmlFindPath</a></li>
<li><a href="#mxmlGetCDATA">mxmlGetCDATA</a></li>
<li><a href="#mxmlGetComment">mxmlGetComment</a></li>
<li><a href="#mxmlGetCustom">mxmlGetCustom</a></li>
<li><a href="#mxmlGetDeclaration">mxmlGetDeclaration</a></li>
<li><a href="#mxmlGetDirective">mxmlGetDirective</a></li>
<li><a href="#mxmlGetElement">mxmlGetElement</a></li>
<li><a href="#mxmlGetFirstChild">mxmlGetFirstChild</a></li>
<li><a href="#mxmlGetInteger">mxmlGetInteger</a></li>
<li><a href="#mxmlGetLastChild">mxmlGetLastChild</a></li>
<li><a href="#mxmlGetNextSibling">mxmlGetNextSibling</a></li>
<li><a href="#mxmlGetOpaque">mxmlGetOpaque</a></li>
<li><a href="#mxmlGetParent">mxmlGetParent</a></li>
<li><a href="#mxmlGetPrevSibling">mxmlGetPrevSibling</a></li>
<li><a href="#mxmlGetReal">mxmlGetReal</a></li>
<li><a href="#mxmlGetRefCount">mxmlGetRefCount</a></li>
<li><a href="#mxmlGetText">mxmlGetText</a></li>
<li><a href="#mxmlGetType">mxmlGetType</a></li>
<li><a href="#mxmlGetUserData">mxmlGetUserData</a></li>
<li><a href="#mxmlIndexDelete">mxmlIndexDelete</a></li>
<li><a href="#mxmlIndexEnum">mxmlIndexEnum</a></li>
<li><a href="#mxmlIndexFind">mxmlIndexFind</a></li>
<li><a href="#mxmlIndexGetCount">mxmlIndexGetCount</a></li>
<li><a href="#mxmlIndexNew">mxmlIndexNew</a></li>
<li><a href="#mxmlIndexReset">mxmlIndexReset</a></li>
<li><a href="#mxmlLoadFd">mxmlLoadFd</a></li>
<li><a href="#mxmlLoadFile">mxmlLoadFile</a></li>
<li><a href="#mxmlLoadFilename">mxmlLoadFilename</a></li>
<li><a href="#mxmlLoadIO">mxmlLoadIO</a></li>
<li><a href="#mxmlLoadString">mxmlLoadString</a></li>
<li><a href="#mxmlNewCDATA">mxmlNewCDATA</a></li>
<li><a href="#mxmlNewCDATAf">mxmlNewCDATAf</a></li>
<li><a href="#mxmlNewComment">mxmlNewComment</a></li>
<li><a href="#mxmlNewCommentf">mxmlNewCommentf</a></li>
<li><a href="#mxmlNewCustom">mxmlNewCustom</a></li>
<li><a href="#mxmlNewDeclaration">mxmlNewDeclaration</a></li>
<li><a href="#mxmlNewDeclarationf">mxmlNewDeclarationf</a></li>
<li><a href="#mxmlNewDirective">mxmlNewDirective</a></li>
<li><a href="#mxmlNewDirectivef">mxmlNewDirectivef</a></li>
<li><a href="#mxmlNewElement">mxmlNewElement</a></li>
<li><a href="#mxmlNewInteger">mxmlNewInteger</a></li>
<li><a href="#mxmlNewOpaque">mxmlNewOpaque</a></li>
<li><a href="#mxmlNewOpaquef">mxmlNewOpaquef</a></li>
<li><a href="#mxmlNewReal">mxmlNewReal</a></li>
<li><a href="#mxmlNewText">mxmlNewText</a></li>
<li><a href="#mxmlNewTextf">mxmlNewTextf</a></li>
<li><a href="#mxmlNewXML">mxmlNewXML</a></li>
<li><a href="#mxmlOptionsDelete">mxmlOptionsDelete</a></li>
<li><a href="#mxmlOptionsNew">mxmlOptionsNew</a></li>
<li><a href="#mxmlOptionsSetCustomCallbacks">mxmlOptionsSetCustomCallbacks</a></li>
<li><a href="#mxmlOptionsSetEntityCallback">mxmlOptionsSetEntityCallback</a></li>
<li><a href="#mxmlOptionsSetErrorCallback">mxmlOptionsSetErrorCallback</a></li>
<li><a href="#mxmlOptionsSetSAXCallback">mxmlOptionsSetSAXCallback</a></li>
<li><a href="#mxmlOptionsSetTypeCallback">mxmlOptionsSetTypeCallback</a></li>
<li><a href="#mxmlOptionsSetTypeValue">mxmlOptionsSetTypeValue</a></li>
<li><a href="#mxmlOptionsSetWhitespaceCallback">mxmlOptionsSetWhitespaceCallback</a></li>
<li><a href="#mxmlOptionsSetWrapMargin">mxmlOptionsSetWrapMargin</a></li>
<li><a href="#mxmlRelease">mxmlRelease</a></li>
<li><a href="#mxmlRemove">mxmlRemove</a></li>
<li><a href="#mxmlRetain">mxmlRetain</a></li>
<li><a href="#mxmlSaveAllocString">mxmlSaveAllocString</a></li>
<li><a href="#mxmlSaveFd">mxmlSaveFd</a></li>
<li><a href="#mxmlSaveFile">mxmlSaveFile</a></li>
<li><a href="#mxmlSaveFilename">mxmlSaveFilename</a></li>
<li><a href="#mxmlSaveIO">mxmlSaveIO</a></li>
<li><a href="#mxmlSaveString">mxmlSaveString</a></li>
<li><a href="#mxmlSetCDATA">mxmlSetCDATA</a></li>
<li><a href="#mxmlSetCDATAf">mxmlSetCDATAf</a></li>
<li><a href="#mxmlSetComment">mxmlSetComment</a></li>
<li><a href="#mxmlSetCommentf">mxmlSetCommentf</a></li>
<li><a href="#mxmlSetCustom">mxmlSetCustom</a></li>
<li><a href="#mxmlSetDeclaration">mxmlSetDeclaration</a></li>
<li><a href="#mxmlSetDeclarationf">mxmlSetDeclarationf</a></li>
<li><a href="#mxmlSetDirective">mxmlSetDirective</a></li>
<li><a href="#mxmlSetDirectivef">mxmlSetDirectivef</a></li>
<li><a href="#mxmlSetElement">mxmlSetElement</a></li>
<li><a href="#mxmlSetInteger">mxmlSetInteger</a></li>
<li><a href="#mxmlSetOpaque">mxmlSetOpaque</a></li>
<li><a href="#mxmlSetOpaquef">mxmlSetOpaquef</a></li>
<li><a href="#mxmlSetReal">mxmlSetReal</a></li>
<li><a href="#mxmlSetText">mxmlSetText</a></li>
<li><a href="#mxmlSetTextf">mxmlSetTextf</a></li>
<li><a href="#mxmlSetUserData">mxmlSetUserData</a></li>
<li><a href="#mxmlWalkNext">mxmlWalkNext</a></li>
<li><a href="#mxmlWalkPrev">mxmlWalkPrev</a></li>
</ul></li>
<li><a href="#TYPES">Data Types</a><ul class="subcontents">
<li><a href="#mxml_add_t">mxml_add_t</a></li>
<li><a href="#mxml_custfree_cb_t">mxml_custfree_cb_t</a></li>
<li><a href="#mxml_custload_cb_t">mxml_custload_cb_t</a></li>
<li><a href="#mxml_custsave_cb_t">mxml_custsave_cb_t</a></li>
<li><a href="#mxml_descend_t">mxml_descend_t</a></li>
<li><a href="#mxml_entity_cb_t">mxml_entity_cb_t</a></li>
<li><a href="#mxml_error_cb_t">mxml_error_cb_t</a></li>
<li><a href="#mxml_index_t">mxml_index_t</a></li>
<li><a href="#mxml_io_cb_t">mxml_io_cb_t</a></li>
<li><a href="#mxml_node_t">mxml_node_t</a></li>
<li><a href="#mxml_options_t">mxml_options_t</a></li>
<li><a href="#mxml_sax_cb_t">mxml_sax_cb_t</a></li>
<li><a href="#mxml_sax_event_t">mxml_sax_event_t</a></li>
<li><a href="#mxml_strcopy_cb_t">mxml_strcopy_cb_t</a></li>
<li><a href="#mxml_strfree_cb_t">mxml_strfree_cb_t</a></li>
<li><a href="#mxml_type_cb_t">mxml_type_cb_t</a></li>
<li><a href="#mxml_type_t">mxml_type_t</a></li>
<li><a href="#mxml_ws_cb_t">mxml_ws_cb_t</a></li>
<li><a href="#mxml_ws_t">mxml_ws_t</a></li>
</ul></li>
<li><a href="#ENUMERATIONS">Enumerations</a><ul class="subcontents">
<li><a href="#mxml_add_e">mxml_add_e</a></li>
<li><a href="#mxml_descend_e">mxml_descend_e</a></li>
<li><a href="#mxml_sax_event_e">mxml_sax_event_e</a></li>
<li><a href="#mxml_type_e">mxml_type_e</a></li>
<li><a href="#mxml_ws_e">mxml_ws_e</a></li>
</ul></li>
</ul>
</div>
<div class="body">
<h2 class="title" id="introduction">Introduction</h2>
<p>Mini-XML is a small XML parsing library that you can use to read XML data files or strings in your application without requiring large non-standard libraries. Mini-XML provides the following functionality:</p>
<ul>
<li><p>Reading of UTF-8 and UTF-16 and writing of UTF-8 encoded XML files and strings.</p>
</li>
<li><p>Data is stored in a linked-list tree structure, preserving the XML data hierarchy.</p>
</li>
<li><p>SAX (streamed) reading of XML files and strings to minimize memory usage.</p>
</li>
<li><p>Supports arbitrary element names, attributes, and attribute values with no preset limits, just available memory.</p>
</li>
<li><p>Supports integer, real, opaque (&quot;CDATA&quot;), text, and custom data types in &quot;leaf&quot; nodes.</p>
</li>
<li><p>Functions for creating and managing trees of data.</p>
</li>
<li><p>&quot;Find&quot; and &quot;walk&quot; functions for easily locating and navigating trees of data.</p>
</li>
<li><p>Support for custom string memory management functions to implement string pools and other schemes for reducing memory usage.</p>
</li>
</ul>
<p>Mini-XML doesn't do validation or other types of processing on the data based upon schema files or other sources of definition information.</p>
<h3 class="title" id="history">History</h3>
<p>Mini-XML was initially developed for the <a href="http://gutenprint.sf.net/">Gutenprint</a> project to replace the rather large and unwieldy <code>libxml2</code> library with something substantially smaller and easier-to-use. It all began one morning in June of 2003 when Robert posted the following sentence to the developer's list:</p>
<blockquote>
<p>It's bad enough that we require libxml2, but rolling our own XML parser is a bit more than we can handle.</p>
</blockquote>
<p>I then replied with:</p>
<blockquote>
<p>Given the limited scope of what you use in XML, it should be trivial to code a mini-XML API in a few hundred lines of code.</p>
</blockquote>
<p>I took my own challenge and coded furiously for two days to produce the initial public release of Mini-XML, total lines of code: 696. Robert promptly integrated Mini-XML into Gutenprint and removed libxml2.</p>
<p>Thanks to lots of feedback and support from various developers, Mini-XML has evolved since then to provide a more complete XML implementation and now stands at a whopping 3,491 lines of code, compared to 175,808 lines of code for libxml2 version 2.11.7.</p>
<h3 class="title" id="resources">Resources</h3>
<p>The Mini-XML home page can be found at <a href="https://www.msweet.org/mxml">https://www.msweet.org/mxml</a>. From there you can download the current version of Mini-XML, access the issue tracker, and find other resources.</p>
<p>Mini-XML v4 has a slightly different API than prior releases. See the <a href="#migrating-from-mini-xml-v3.x">Migrating from Mini-XML v3.x</a> chapter for details.</p>
<h3 class="title" id="legal-stuff">Legal Stuff</h3>
<p>The Mini-XML library is copyright © 2003-2024 by Michael R Sweet and is provided under the Apache License Version 2.0 with an (optional) exception to allow linking against GPL2/LGPL2-only software. See the files &quot;LICENSE&quot; and &quot;NOTICE&quot; for more information.</p>
<h2 class="title" id="using-mini-xml">Using Mini-XML</h2>
<p>Mini-XML provides a single header file which you include:</p>
<pre><code class="language-c"><span class="directive">#include &lt;mxml.h&gt;</span>
</code></pre>
<p>The Mini-XML library is included with your program using the <code>-lmxml4</code> option:</p>
<pre><code>gcc -o myprogram myprogram.c -lmxml4
</code></pre>
<p>If you have the <code>pkg-config</code> software installed, you can use it to determine the proper compiler and linker options for your installation:</p>
<pre><code>gcc `pkg-config --cflags mxml4` -o myprogram myprogram.c `pkg-config --libs mxml4`
</code></pre>
<p>&gt; Note: The library name &quot;mxml4&quot; is a configure-time option. If you use the</p>
<blockquote>
<p><code>--disable-libmxml4-prefix</code> configure option the library is named &quot;mxml&quot;.</p>
</blockquote>
<h3 class="title" id="api-basics">API Basics</h3>
<p>Every piece of information in an XML file is stored in memory in &quot;nodes&quot;. Nodes are represented by <code>mxml_node_t</code> pointers. Each node has an associated type, value(s), a parent node, sibling nodes (previous and next), potentially first and last child nodes, and an optional user data pointer.</p>
<p>For example, if you have an XML file like the following:</p>
<pre><code class="language-xml"><span class="directive">&lt;?xml version=</span><span class="string">&quot;1.0&quot;</span><span class="directive"> encoding=</span><span class="string">&quot;utf-8&quot;</span><span class="directive">?&gt;</span>
<span class="reserved">&lt;data&gt;</span>
    <span class="reserved">&lt;node&gt;</span>val1<span class="reserved">&lt;/node&gt;</span>
    <span class="reserved">&lt;node&gt;</span>val2<span class="reserved">&lt;/node&gt;</span>
    <span class="reserved">&lt;node&gt;</span>val3<span class="reserved">&lt;/node&gt;</span>
    <span class="reserved">&lt;group&gt;</span>
        <span class="reserved">&lt;node&gt;</span>val4<span class="reserved">&lt;/node&gt;</span>
        <span class="reserved">&lt;node&gt;</span>val5<span class="reserved">&lt;/node&gt;</span>
        <span class="reserved">&lt;node&gt;</span>val6<span class="reserved">&lt;/node&gt;</span>
    <span class="reserved">&lt;/group&gt;</span>
    <span class="reserved">&lt;node&gt;</span>val7<span class="reserved">&lt;/node&gt;</span>
    <span class="reserved">&lt;node&gt;</span>val8<span class="reserved">&lt;/node&gt;</span>
<span class="reserved">&lt;/data&gt;</span>
</code></pre>
<p>the node tree for the file would look like the following in memory:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
  |
&lt;data&gt;
  |
&lt;node&gt; - &lt;node&gt; - &lt;node&gt; - &lt;group&gt; - &lt;node&gt; - &lt;node&gt;
  |        |        |         |        |        |
 val1     val2     val3       |       val7     val8
                              |
                            &lt;node&gt; - &lt;node&gt; - &lt;node&gt;
                              |        |        |
                             val4     val5     val6
</code></pre>
<p>where &quot;-&quot; is a pointer to the sibling node and &quot;|&quot; is a pointer to the first child or parent node.</p>
<p>The <a href="#mxmlGetType">mxmlGetType</a> function gets the type of a node which is represented as a <code>mxml_type_t</code> enumeration value:</p>
<ul>
<li><p><code>MXML_TYPE_CDATA</code>: CDATA such as <code>&lt;![CDATA[...]]&gt;</code>,</p>
</li>
<li><p><code>MXML_TYPE_COMMENT</code>: A comment such as <code>&lt;!-- my comment --&gt;</code>,</p>
</li>
<li><p><code>MXML_TYPE_CUSTOM</code>: A custom value defined by your application,</p>
</li>
<li><p><code>MXML_TYPE_DECLARATION</code>: A declaration such as <code>&lt;!DOCTYPE html&gt;</code>,</p>
</li>
<li><p><code>MXML_TYPE_DIRECTIVE</code>: A processing instruction such as <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code>,</p>
</li>
<li><p><code>MXML_TYPE_ELEMENT</code>: An XML element with optional attributes such as <code>&lt;element name=&quot;value&quot;&gt;</code>,</p>
</li>
<li><p><code>MXML_TYPE_INTEGER</code>: A whitespace-delimited integer value such as <code>42</code>,</p>
</li>
<li><p><code>MXML_TYPE_OPAQUE</code>: An opaque string value that preserves all whitespace such as <code>All work and no play makes Johnny a dull boy.</code>,</p>
</li>
<li><p><code>MXML_TYPE_REAL</code>: A whitespace-delimited floating point value such as <code>123.4</code>, or</p>
</li>
<li><p><code>MXML_TYPE_TEXT</code>: A whitespace-delimited text (fragment) value such as <code>Word</code>.</p>
</li>
</ul>
<p>The parent, sibling, and child nodes are accessed using the <a href="#mxmlGetParent">mxmlGetParent</a>, <a href="#mxmlGetNextSibling">mxmlGetNextSibling</a>, <a href="#mxmlGetPreviousSibling">mxmlGetPreviousSibling</a>, <a href="#mxmlGetFirstChild">mxmlGetFirstChild</a>, and <a href="#mxmlGetLastChild">mxmlGetLastChild</a> functions.</p>
<p>The value(s) of a node are accessed using the <a href="#mxmlGetCDATA">mxmlGetCDATA</a>, <a href="#mxmlGetComment">mxmlGetComment</a>, <a href="#mxmlGetDeclaration">mxmlGetDeclaration</a>, <a href="#mxmlGetDirective">mxmlGetDirective</a>, <a href="#mxmlGetElement">mxmlGetElement</a>, <a href="#mxmlElementGetAttr">mxmlElementGetAttr</a>, <a href="#mxmlGetInteger">mxmlGetInteger</a>, <a href="#mxmlGetOpaque">mxmlGetOpaque</a>, <a href="#mxmlGetReal">mxmlGetReal</a>, and <a href="#mxmlGetText">mxmlGetText</a> functions.</p>
<h3 class="title" id="loading-an-xml-file">Loading an XML File</h3>
<p>You load an XML file using the <a href="#mxmlLoadFilename">mxmlLoadFilename</a> function:</p>
<pre><code class="language-c">mxml_node_t *
mxmlLoadFilename(mxml_node_t *top, mxml_options_t *options,
                 <span class="reserved">const</span> <span class="reserved">char</span> *filename);
</code></pre>
<p>Mini-XML also provides functions to load from a <code>FILE</code> pointer, a file descriptor, a string, or using a callback:</p>
<pre><code class="language-c">mxml_node_t *
mxmlLoadFd(mxml_node_t *top, mxml_options_t *options,
           <span class="reserved">int</span> fd);

mxml_node_t *
mxmlLoadFile(mxml_node_t *top, mxml_options_t *options,
             FILE *fp);

mxml_node_t *
mxmlLoadIO(mxml_node_t *top, mxml_options_t *options,
           mxml_io_cb_t io_cb, <span class="reserved">void</span> *io_cbdata);

mxml_node_t *
mxmlLoadString(mxml_node_t *top, mxml_options_t *options,
               <span class="reserved">const</span> <span class="reserved">char</span> *s);
</code></pre>
<p>Each accepts a pointer to the top-most (&quot;root&quot;) node (usually <code>NULL</code>) you want to add the XML data to, any load options, and the content to be loaded. For example, the following code will load an XML file called &quot;example.xml&quot; using the default load options:</p>
<pre><code class="language-c">mxml_node_t *xml;

xml = mxmlLoadFilename(<span class="comment">/*top*/</span>NULL, <span class="comment">/*options*/</span>NULL,
                       <span class="string">&quot;example.xml&quot;</span>);
</code></pre>
<h4 id="load-options">Load Options</h4>
<p>Load options are specified using a <code>mxml_options_t</code> pointer, which you create using the <a href="#mxmlOptionsNew">mxmlOptionsNew</a> function:</p>
<pre><code class="language-c">mxml_options_t *options = mxmlOptionsNew();
</code></pre>
<p>The default load options will treat any values in your XML as whitespace- delimited text (<code>MXML_TYPE_TEXT</code>). You can specify a different type of values using the <a href="#mxmlOptionsSetTypeValue">mxmlOptionsSetTypeValue</a> function. For example, the following will specify that values are opaque text strings, including whitespace (<code>MXML_TYPE_OPAQUE</code>):</p>
<pre><code class="language-c">mxmlOptionsSetTypeValue(options, MXML_TYPE_OPAQUE);
</code></pre>
<p>For more complex XML documents, you can specify a callback that returns the type of value for a given element node using the <a href="#mxmlOptionsSetTypeCallback">mxmlOptionsSetTypeCallback</a> function. For example, to specify a callback function called <code>my_type_cb</code> that has no callback data:</p>
<pre><code class="language-c">mxmlOptionsSetTypeCallback(options, my_type_cb, <span class="comment">/*cbdata*/</span>NULL);
</code></pre>
<p>The <code>my_type_cb</code> function accepts the callback data pointer (<code>NULL</code> in this case) and the <code>mxml_node_t</code> pointer for the current element and returns a <code>mxml_type_t</code> enumeration value specifying the value type for child nodes. For example, the following function looks at the &quot;type&quot; attribute and the element name to determine the value types of the node's children:</p>
<pre><code class="language-c">mxml_type_t
my_load_cb(<span class="reserved">void</span> *cbdata, mxml_node_t *node)
{
  <span class="reserved">const</span> <span class="reserved">char</span> *type;

 <span class="comment">/*</span>
<span class="comment">  * You can lookup attributes and/or use the element name,</span>
<span class="comment">  * hierarchy, etc...</span>
<span class="comment">  */</span>

  type = mxmlElementGetAttr(node, <span class="string">&quot;type&quot;</span>);
  <span class="reserved">if</span> (type == NULL)
    type = mxmlGetElement(node);
  <span class="reserved">if</span> (type == NULL)
    type = <span class="string">&quot;text&quot;</span>;

  <span class="reserved">if</span> (!strcmp(type, <span class="string">&quot;integer&quot;</span>))
    <span class="reserved">return</span> (MXML_TYPE_INTEGER);
  <span class="reserved">else</span> <span class="reserved">if</span> (!strcmp(type, <span class="string">&quot;opaque&quot;</span>))
    <span class="reserved">return</span> (MXML_TYPE_OPAQUE);
  <span class="reserved">else</span> <span class="reserved">if</span> (!strcmp(type, <span class="string">&quot;real&quot;</span>))
    <span class="reserved">return</span> (MXML_TYPE_REAL);
  <span class="reserved">else</span>
    <span class="reserved">return</span> (MXML_TYPE_TEXT);
}
</code></pre>
<h3 class="title" id="finding-nodes">Finding Nodes</h3>
<p>The <a href="#mxmlFindPath">mxmlFindPath</a> function finds the (first) value node under a specific element using a path. The path string can contain the &quot;*&quot; wildcard to match a single element node in the hierarchy. For example, the following code will find the first &quot;node&quot; element under the &quot;group&quot; element, first using an explicit path and then using a wildcard:</p>
<pre><code class="language-c">mxml_node_t *directnode = mxmlFindPath(xml, <span class="string">&quot;data/group/node&quot;</span>);

mxml_node_t *wildnode = mxmlFindPath(xml, <span class="string">&quot;data/*/node&quot;</span>);
</code></pre>
<p>The <a href="#mxmlFindElement">mxmlFindElement</a> function can be used to find a named element, optionally matching an attribute and value:</p>
<pre><code class="language-c">mxml_node_t *
mxmlFindElement(mxml_node_t *node, mxml_node_t *top,
                <span class="reserved">const</span> <span class="reserved">char</span> *element, <span class="reserved">const</span> <span class="reserved">char</span> *attr,
                <span class="reserved">const</span> <span class="reserved">char</span> *value, <span class="reserved">int</span> descend);
</code></pre>
<p>The <code>element</code>, <code>attr</code>, and <code>value</code> arguments can be passed as <code>NULL</code> to act as wildcards, e.g.:</p>
<pre><code class="language-c">mxml_node_t *node;

<span class="comment">/* Find the first &quot;a&quot; element */</span>
node = mxmlFindElement(tree, tree, <span class="string">&quot;a&quot;</span>, NULL, NULL,
                       MXML_DESCEND_ALL);

<span class="comment">/* Find the first &quot;a&quot; element with &quot;href&quot; attribute */</span>
node = mxmlFindElement(tree, tree, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;href&quot;</span>, NULL,
                       MXML_DESCEND_ALL);

<span class="comment">/* Find the first &quot;a&quot; element with &quot;href&quot; to a URL */</span>
node = mxmlFindElement(tree, tree, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;href&quot;</span>,
                       <span class="string">&quot;http://msweet.org/&quot;</span>,
                       MXML_DESCEND_ALL);

<span class="comment">/* Find the first element with a &quot;src&quot; attribute*/</span>
node = mxmlFindElement(tree, tree, NULL, <span class="string">&quot;src&quot;</span>, NULL,
                       MXML_DESCEND_ALL);

<span class="comment">/* Find the first element with a &quot;src&quot; = &quot;foo.jpg&quot; */</span>
node = mxmlFindElement(tree, tree, NULL, <span class="string">&quot;src&quot;</span>, <span class="string">&quot;foo.jpg&quot;</span>,
                       MXML_DESCEND_ALL);
</code></pre>
<p>You can also iterate with the same function:</p>
<pre><code class="language-c">mxml_node_t *node;

<span class="reserved">for</span> (node = mxmlFindElement(tree, tree, <span class="string">&quot;element&quot;</span>, NULL,
                            NULL, MXML_DESCEND_ALL);
     node != NULL;
     node = mxmlFindElement(node, tree, <span class="string">&quot;element&quot;</span>, NULL,
                            NULL, MXML_DESCEND_ALL))
{
  ... <span class="reserved">do</span> something ...
}
</code></pre>
<p>The <code>descend</code> argument (<code>MXML_DESCEND_ALL</code> in the previous examples) can be one of three constants:</p>
<ul>
<li><p><code>MXML_DESCEND_NONE</code>: ignore child nodes in the element hierarchy, instead using siblings (same level) or parent nodes (above) until the top (root) node is reached.</p>
</li>
<li><p><code>MXML_DESCEND_FIRST</code>: start the search with the first child of the node, and then search siblings. You'll normally use this when iterating through direct children of a parent node, e.g. all of the <code>&lt;node&gt;</code> and <code>&lt;group&gt;</code> elements under the <code>&lt;?xml ...?&gt;</code> parent node in the previous example.</p>
</li>
<li><p><code>MXML_DESCEND_ALL</code>: search child nodes first, then sibling nodes, and then parent nodes.</p>
</li>
</ul>
<h3 class="title" id="getting-the-values-from-nodes">Getting the Value(s) from Nodes</h3>
<p>Once you have the node you can use one of the mxmlGetXxx functions to retrieve its value(s).</p>
<p>Element (<code>MXML_TYPE_ELEMENT</code>) nodes have an associated name and zero or more named attributes with (string) values. The <a href="#mxmlGetElement">mxmlGetElement</a> function retrieves the element name while the <a href="#mxmlElementGetAttr">mxmlElementGetAttr</a> function retrieves the value string for a named attribute. For example, the following code looks for HTML heading elements and, when found, displays the &quot;id&quot; attribute for the heading:</p>
<pre><code class="language-c"><span class="reserved">const</span> <span class="reserved">char</span> *elemname = mxmlGetElement(node);
<span class="reserved">const</span> <span class="reserved">char</span> *id_value = mxmlElementGetAttr(node, <span class="string">&quot;id&quot;</span>);

<span class="reserved">if</span> ((*elemname == <span class="string">'h'</span> || *elemname == <span class="string">'H'</span>) &amp;&amp;
    elemname[<span class="number">1</span>] &gt;= <span class="string">'1'</span> &amp;&amp; elemname[<span class="number">1</span>] &lt;= <span class="string">'6'</span> &amp;&amp;
    id_value != NULL)
  printf(<span class="string">&quot;%s: %s\n&quot;</span>, elemname, id_value);
</code></pre>
<p>The <a href="#mxmlElementGetAttrByIndex">mxmlElementGetAttrByIndex</a> and <a href="#mxmlElementGetAttrCount">mxmlElementGetAttrCount</a> functions allow you to iterate all attributes of an element. For example, the following code prints the element name and each of its attributes:</p>
<pre><code class="language-c"><span class="reserved">const</span> <span class="reserved">char</span> *elemname = mxmlGetElement(node);
printf(<span class="string">&quot;%s:\n&quot;</span>, elemname);

size_t i, count;
<span class="reserved">for</span> (i = <span class="number">0</span>, count = mxmlElementGetAttrCount(node); i &lt; count; i ++)
{
  <span class="reserved">const</span> <span class="reserved">char</span> *attrname, *attrvalue;

  attrvalue = mxmlElementGetAttrByIndex(node, i, &amp;attrname);

  printf(<span class="string">&quot;    %s=\&quot;%s\&quot;\n&quot;</span>, attrname, attrvalue);
}
</code></pre>
<p>CDATA (<code>MXML_TYPE_CDATA</code>) nodes have an associated string value consisting of the text between the <code>&lt;![CDATA[</code> and <code>]]&gt;</code> delimiters. The <a href="#mxmlGetCDATA">mxmlGetCDATA</a> function retrieves the CDATA string pointer for a node. For example, the following code gets the CDATA string value:</p>
<pre><code class="language-c"><span class="reserved">const</span> <span class="reserved">char</span> *cdatavalue = mxmlGetCDATA(node);
</code></pre>
<p>Comment (<code>MXML_TYPE_COMMENT</code>) nodes have an associated string value consisting of the text between the <code>&lt;!--</code> and <code>--&gt;</code> delimiters. The <a href="#mxmlGetComment">mxmlGetComment</a> function retrieves the comment string pointer for a node. For example, the following code gets the comment string value:</p>
<pre><code class="language-c"><span class="reserved">const</span> <span class="reserved">char</span> *commentvalue = mxmlGetComment(node);
</code></pre>
<p>Processing instruction (<code>MXML_TYPE_DIRECTIVE</code>) nodes have an associated string value consisting of the text between the <code>&lt;?</code> and <code>?&gt;</code> delimiters. The <a href="#mxmlGetDirective">mxmlGetDirective</a> function retrieves the processing instruction string for a node. For example, the following code gets the processing instruction string value:</p>
<pre><code class="language-c"><span class="reserved">const</span> <span class="reserved">char</span> *instrvalue = mxmlGetDirective(node);
</code></pre>
<p>Integer (<code>MXML_TYPE_INTEGER</code>) nodes have an associated <code>long</code> value. The <a href="#mxmlGetInteger">mxmlGetInteger</a> function retrieves the integer value for a node. For example, the following code gets the integer value:</p>
<pre><code class="language-c"><span class="reserved">long</span> intvalue = mxmlGetInteger(node);
</code></pre>
<p>Opaque string (<code>MXML_TYPE_OPAQUE</code>) nodes have an associated string value consisting of the text between elements. The <a href="#mxmlGetOpaque">mxmlGetOpaque</a> function retrieves the opaque string pointer for a node. For example, the following code gets the opaque string value:</p>
<pre><code class="language-c"><span class="reserved">const</span> <span class="reserved">char</span> *opaquevalue = mxmlGetOpaque(node);
</code></pre>
<p>Real number (<code>MXML_TYPE_REAL</code>) nodes have an associated <code>double</code> value. The <a href="#mxmlGetReal">mxmlGetReal</a> function retrieves the real number for a node. For example, the following code gets the real value:</p>
<pre><code class="language-c"><span class="reserved">double</span> realvalue = mxmlGetReal(node);
</code></pre>
<p>Whitespace-delimited text string (<code>MXML_TYPE_TEXT</code>) nodes have an associated whitespace indicator and string value extracted from the text between elements. The <a href="#mxmlGetText">mxmlGetText</a> function retrieves the text string pointer and whitespace boolean value for a node. For example, the following code gets the text and whitespace indicator:</p>
<pre><code class="language-c"><span class="reserved">const</span> <span class="reserved">char</span> *textvalue;
<span class="reserved">bool</span> whitespace;

textvalue = mxmlGetText(node, &amp;whitespace);
</code></pre>
<h3 class="title" id="saving-an-xml-file">Saving an XML File</h3>
<p>You save an XML file using the <a href="#mxmlSaveFilename">mxmlSaveFilename</a> function:</p>
<pre><code class="language-c"><span class="reserved">bool</span>
mxmlSaveFilename(mxml_node_t *node, mxml_options_t *options,
                 <span class="reserved">const</span> <span class="reserved">char</span> *filename);
</code></pre>
<p>Mini-XML also provides functions to save to a <code>FILE</code> pointer, a file descriptor, a string, or using a callback:</p>
<pre><code class="language-c"><span class="reserved">char</span> *
mxmlSaveAllocString(mxml_node_t *node, mxml_options_t *options);

<span class="reserved">bool</span>
mxmlSaveFd(mxml_node_t *node, mxml_options_t *options,
           <span class="reserved">int</span> fd);

<span class="reserved">bool</span>
mxmlSaveFile(mxml_node_t *node, mxml_options_t *options,
             FILE *fp);

<span class="reserved">bool</span>
mxmlSaveIO(mxml_node_t *node, mxml_options_t *options,
           mxml_io_cb_t *io_cb, <span class="reserved">void</span> *io_cbdata);

size_t
mxmlSaveString(mxml_node_t *node, mxml_options_t *options,
               <span class="reserved">char</span> *buffer, size_t bufsize);
</code></pre>
<p>Each accepts a pointer to the top-most (&quot;root&quot;) node, any save options, and (as needed) the destination. For example, the following code saves an XML file to the file &quot;example.xml&quot; with the default options:</p>
<pre><code class="language-c">mxmlSaveFile(xml, <span class="comment">/*options*/</span>NULL, <span class="string">&quot;example.xml&quot;</span>);
</code></pre>
<h4 id="save-options">Save Options</h4>
<p>Save options are specified using a <code>mxml_options_t</code> pointer, which you create using the <a href="#mxmlOptionsNew">mxmlOptionsNew</a> function:</p>
<pre><code class="language-c">mxml_options_t *options = mxmlOptionsNew();
</code></pre>
<p>The default save options will wrap output lines at column 72 but not add any additional whitespace otherwise. You can change the wrap column using the <a href="#mxmlOptionsSetWrapMargin">mxmlOptionsSetWrapMargin</a> function. For example, the following will set the wrap column to 0 which disables wrapping:</p>
<pre><code class="language-c">mxmlOptionsSetWrapMargin(options, <span class="number">0</span>);
</code></pre>
<p>To add additional whitespace to the output, set a whitespace callback using the <a href="#mxmlOptionsSetWhitespaceCallback">mxmlOptionsSetWhitespaceCallback</a> function. A whitespace callback accepts a callback data pointer, the current node, and a whitespace position value of <code>MXML_WS_BEFORE_OPEN</code>, <code>MXML_WS_AFTER_OPEN</code>, <code>MXML_WS_BEFORE_CLOSE</code>, or <code>MXML_WS_AFTER_CLOSE</code>. The callback should return <code>NULL</code> if no whitespace is to be inserted or a string of spaces, tabs, carriage returns, and newlines to insert otherwise.</p>
<p>The following whitespace callback can be used to add whitespace to XHTML output to make it more readable in a standard text editor:</p>
<pre><code class="language-c"><span class="reserved">const</span> <span class="reserved">char</span> *
whitespace_cb(<span class="reserved">void</span> *cbdata, mxml_node_t *node, mxml_ws_t where)
{
  <span class="reserved">const</span> <span class="reserved">char</span> *element;

 <span class="comment">/*</span>
<span class="comment">  * We can conditionally break to a new line before or after</span>
<span class="comment">  * any element.  These are just common HTML elements...</span>
<span class="comment">  */</span>

  element = mxmlGetElement(node);

  <span class="reserved">if</span> (!strcmp(element, <span class="string">&quot;html&quot;</span>) ||
      !strcmp(element, <span class="string">&quot;head&quot;</span>) ||
      !strcmp(element, <span class="string">&quot;body&quot;</span>) ||
      !strcmp(element, <span class="string">&quot;pre&quot;</span>) ||
      !strcmp(element, <span class="string">&quot;p&quot;</span>) ||
      !strcmp(element, <span class="string">&quot;h1&quot;</span>) ||
      !strcmp(element, <span class="string">&quot;h2&quot;</span>) ||
      !strcmp(element, <span class="string">&quot;h3&quot;</span>) ||
      !strcmp(element, <span class="string">&quot;h4&quot;</span>) ||
      !strcmp(element, <span class="string">&quot;h5&quot;</span>) ||
      !strcmp(element, <span class="string">&quot;h6&quot;</span>))
  {
   <span class="comment">/*</span>
<span class="comment">    * Newlines before open and after close...</span>
<span class="comment">    */</span>

    <span class="reserved">if</span> (where == MXML_WS_BEFORE_OPEN ||
        where == MXML_WS_AFTER_CLOSE)
      <span class="reserved">return</span> (<span class="string">&quot;\n&quot;</span>);
  }
  <span class="reserved">else</span> <span class="reserved">if</span> (!strcmp(element, <span class="string">&quot;dl&quot;</span>) ||
           !strcmp(element, <span class="string">&quot;ol&quot;</span>) ||
           !strcmp(element, <span class="string">&quot;ul&quot;</span>))
  {
   <span class="comment">/*</span>
<span class="comment">    * Put a newline before and after list elements...</span>
<span class="comment">    */</span>

    <span class="reserved">return</span> (<span class="string">&quot;\n&quot;</span>);
  }
  <span class="reserved">else</span> <span class="reserved">if</span> (!strcmp(element, <span class="string">&quot;dd&quot;</span>) ||
           !strcmp(element, <span class="string">&quot;dt&quot;</span>) ||
           !strcmp(element, <span class="string">&quot;li&quot;</span>))
  {
   <span class="comment">/*</span>
<span class="comment">    * Put a tab before &lt;li&gt;'s, &lt;dd&gt;'s, and &lt;dt&gt;'s, and a</span>
<span class="comment">    * newline after them...</span>
<span class="comment">    */</span>

    <span class="reserved">if</span> (where == MXML_WS_BEFORE_OPEN)
      <span class="reserved">return</span> (<span class="string">&quot;\t&quot;</span>);
    <span class="reserved">else</span> <span class="reserved">if</span> (where == MXML_WS_AFTER_CLOSE)
      <span class="reserved">return</span> (<span class="string">&quot;\n&quot;</span>);
  }

 <span class="comment">/*</span>
<span class="comment">  * Otherwise return NULL for no added whitespace...</span>
<span class="comment">  */</span>

  <span class="reserved">return</span> (NULL);
}
</code></pre>
<p>The following code will set the whitespace callback for the save options:</p>
<pre><code class="language-c">mxmlOptionsSetWhitespaceCallback(options, whitespace_cb, <span class="comment">/*cbdata*/</span>NULL);
</code></pre>
<h3 class="title" id="freeing-memory">Freeing Memory</h3>
<p>Once you are done with the XML data, use the <a href="#mxmlDelete">mxmlDelete</a> function to free the memory that is used for a particular node and its children. For example, the following code frees the XML data loaded by the previous examples:</p>
<pre><code class="language-c">mxmlDelete(xml);
</code></pre>
<h2 class="title" id="creating-new-xml-documents">Creating New XML Documents</h2>
<p>You can create new and update existing XML documents in memory using the various mxmlNewXxx functions. The following code will create the XML document described in the <a href="#using-mini-xml">Using Mini-XML</a> chapter:</p>
<pre><code class="language-c">mxml_node_t *xml;    <span class="comment">/* &lt;?xml version=&quot;1.0&quot; charset=&quot;utf-8&quot;?&gt; */</span>
mxml_node_t *data;   <span class="comment">/* &lt;data&gt; */</span>
mxml_node_t *node;   <span class="comment">/* &lt;node&gt; */</span>
mxml_node_t *group;  <span class="comment">/* &lt;group&gt; */</span>

xml = mxmlNewXML(<span class="string">&quot;1.0&quot;</span>);

data = mxmlNewElement(xml, <span class="string">&quot;data&quot;</span>);

  node = mxmlNewElement(data, <span class="string">&quot;node&quot;</span>);
  mxmlNewText(node, <span class="reserved">false</span>, <span class="string">&quot;val1&quot;</span>);
  node = mxmlNewElement(data, <span class="string">&quot;node&quot;</span>);
  mxmlNewText(node, <span class="reserved">false</span>, <span class="string">&quot;val2&quot;</span>);
  node = mxmlNewElement(data, <span class="string">&quot;node&quot;</span>);
  mxmlNewText(node, <span class="reserved">false</span>, <span class="string">&quot;val3&quot;</span>);

  group = mxmlNewElement(data, <span class="string">&quot;group&quot;</span>);

    node = mxmlNewElement(group, <span class="string">&quot;node&quot;</span>);
    mxmlNewText(node, <span class="reserved">false</span>, <span class="string">&quot;val4&quot;</span>);
    node = mxmlNewElement(group, <span class="string">&quot;node&quot;</span>);
    mxmlNewText(node, <span class="reserved">false</span>, <span class="string">&quot;val5&quot;</span>);
    node = mxmlNewElement(group, <span class="string">&quot;node&quot;</span>);
    mxmlNewText(node, <span class="reserved">false</span>, <span class="string">&quot;val6&quot;</span>);

  node = mxmlNewElement(data, <span class="string">&quot;node&quot;</span>);
  mxmlNewText(node, <span class="reserved">false</span>, <span class="string">&quot;val7&quot;</span>);
  node = mxmlNewElement(data, <span class="string">&quot;node&quot;</span>);
  mxmlNewText(node, <span class="reserved">false</span>, <span class="string">&quot;val8&quot;</span>);
</code></pre>
<p>We start by creating the processing instruction node common to all XML files using the <a href="#mxmlNewXML">mxmlNewXML</a> function:</p>
<pre><code class="language-c">xml = mxmlNewXML(<span class="string">&quot;1.0&quot;</span>);
</code></pre>
<p>We then create the <code>&lt;data&gt;</code> node used for this document using the <a href="#mxmlNewElement">mxmlNewElement</a> function. The first argument specifies the parent node (<code>xml</code>) while the second specifies the element name (<code>data</code>):</p>
<pre><code class="language-c">data = mxmlNewElement(xml, <span class="string">&quot;data&quot;</span>);
</code></pre>
<p>Each <code>&lt;node&gt;...&lt;/node&gt;</code> in the file is created using the <a href="#mxmlNewElement">mxmlNewElement</a> and <a href="#mxmlNewText">mxmlNewText</a> functions. The first argument of <a href="#mxmlNewText">mxmlNewText</a> specifies the parent node (<code>node</code>). The second argument specifies whether whitespace appears before the text - <code>false</code> in this case. The last argument specifies the actual text to add:</p>
<pre><code class="language-c">node = mxmlNewElement(data, <span class="string">&quot;node&quot;</span>);
mxmlNewText(node, <span class="reserved">false</span>, <span class="string">&quot;val1&quot;</span>);
</code></pre>
<p>The resulting in-memory XML document can then be saved or processed just like one loaded from disk or a string.</p>
<h3 class="title" id="element-nodes">Element Nodes</h3>
<p>Element (<code>MXML_TYPE_ELEMENT</code>) nodes are created using the <a href="#mxmlNewElement">mxmlNewElement</a> function. Element attributes are set using the <a href="#mxmlElementSetAttr">mxmlElementSetAttr</a> and <a href="#mxmlElementSetAttrf">mxmlElementSetAttrf</a> functions and cleared using the <a href="#mxmlElementClearAttr">mxmlElementClearAttr</a> function:</p>
<pre><code class="language-c">mxml_node_t *
mxmlNewElement(mxml_node_t *parent, <span class="reserved">const</span> <span class="reserved">char</span> *name);

<span class="reserved">void</span>
mxmlElementClearAttr(mxml_node_t *node, <span class="reserved">const</span> <span class="reserved">char</span> *name);

<span class="reserved">void</span>
mxmlElementSetAttr(mxml_node_t *node, <span class="reserved">const</span> <span class="reserved">char</span> *name,
                   <span class="reserved">const</span> <span class="reserved">char</span> *value);

<span class="reserved">void</span>
mxmlElementSetAttrf(mxml_node_t *node, <span class="reserved">const</span> <span class="reserved">char</span> *name,
                    <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);
</code></pre>
<h3 class="title" id="cdata-nodes">CDATA Nodes</h3>
<p>CDATA (<code>MXML_TYPE_CDATA</code>) nodes are created using the <a href="#mxmlNewCDATA">mxmlNewCDATA</a> and <a href="#mxmlNewCDATAf">mxmlNewCDATAf</a> functions and set using the <a href="#mxmlSetCDATA">mxmlSetCDATA</a> and <a href="#mxmlSetCDATAf">mxmlSetCDATAf</a> functions:</p>
<pre><code class="language-c">mxml_node_t *
mxmlNewCDATA(mxml_node_t *parent, <span class="reserved">const</span> <span class="reserved">char</span> *string);

mxml_node_t *
mxmlNewCDATAf(mxml_node_t *parent, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);

<span class="reserved">void</span>
mxmlSetCDATA(mxml_node_t *node, <span class="reserved">const</span> <span class="reserved">char</span> *string);

<span class="reserved">void</span>
mxmlSetCDATAf(mxml_node_t *node, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);
</code></pre>
<h3 class="title" id="comment-nodes">Comment Nodes</h3>
<p>Comment (<code>MXML_TYPE_COMMENT</code>) nodes are created using the <a href="#mxmlNewComment">mxmlNewComment</a> and <a href="#mxmlNewCommentf">mxmlNewCommentf</a> functions and set using the <a href="#mxmlSetComment">mxmlSetComment</a> and <a href="#mxmlSetCommentf">mxmlSetCommentf</a> functions:</p>
<pre><code class="language-c">mxml_node_t *
mxmlNewComment(mxml_node_t *parent, <span class="reserved">const</span> <span class="reserved">char</span> *string);

mxml_node_t *
mxmlNewCommentf(mxml_node_t *parent, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);

<span class="reserved">void</span>
mxmlSetComment(mxml_node_t *node, <span class="reserved">const</span> <span class="reserved">char</span> *string);

<span class="reserved">void</span>
mxmlSetCommentf(mxml_node_t *node, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);
</code></pre>
<h3 class="title" id="processing-instruction-nodes">Processing Instruction Nodes</h3>
<p>Processing instruction (<code>MXML_TYPE_DIRECTIVE</code>) nodes are created using the <a href="#mxmlNewDirective">mxmlNewDirective</a> and <a href="#mxmlNewDirectivef">mxmlNewDirectivef</a> functions and set using the <a href="#mxmlSetDirective">mxmlSetDirective</a> and <a href="#mxmlSetDirectivef">mxmlSetDirectivef</a> functions:</p>
<pre><code class="language-c">mxml_node_t *node = mxmlNewDirective(<span class="string">&quot;xml-stylesheet type=\&quot;text/css\&quot; href=\&quot;style.css\&quot;&quot;</span>);

mxml_node_t *node = mxmlNewDirectivef(<span class="string">&quot;xml version=\&quot;%s\&quot;&quot;</span>, version);
</code></pre>
<p>The <a href="#mxmlNewXML">mxmlNewXML</a> function can be used to create the top-level &quot;xml&quot; processing instruction with an associated version number:</p>
<pre><code class="language-c">mxml_node_t *
mxmlNewXML(<span class="reserved">const</span> <span class="reserved">char</span> *version);
</code></pre>
<h3 class="title" id="integer-nodes">Integer Nodes</h3>
<p>Integer (<code>MXML_TYPE_INTEGER</code>) nodes are created using the <a href="#mxmlNewInteger">mxmlNewInteger</a> function and set using the <a href="#mxmlSetInteger">mxmlSetInteger</a> function:</p>
<pre><code class="language-c">mxml_node_t *
mxmlNewInteger(mxml_node_t *parent, <span class="reserved">long</span> integer);

<span class="reserved">void</span>
mxmlSetInteger(mxml_node_t *node, <span class="reserved">long</span> integer);
</code></pre>
<h3 class="title" id="opaque-string-nodes">Opaque String Nodes</h3>
<p>Opaque string (<code>MXML_TYPE_OPAQUE</code>) nodes are created using the <a href="#mxmlNewOpaque">mxmlNewOpaque</a> and <a href="#mxmlNewOpaquef">mxmlNewOpaquef</a> functions and set using the <a href="#mxmlSetOpaque">mxmlSetOpaque</a> and <a href="#mxmlSetOpaquef">mxmlSetOpaquef</a> functions:</p>
<pre><code class="language-c">mxml_node_t *
mxmlNewOpaque(mxml_node_t *parent, <span class="reserved">const</span> <span class="reserved">char</span> *opaque);

mxml_node_t *
mxmlNewOpaquef(mxml_node_t *parent, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);

<span class="reserved">void</span>
mxmlSetOpaque(mxml_node_t *node, <span class="reserved">const</span> <span class="reserved">char</span> *opaque);

<span class="reserved">void</span>
mxmlSetOpaquef(mxml_node_t *node, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);
</code></pre>
<h3 class="title" id="real-number-nodes">Real Number Nodes</h3>
<p>Real number (<code>MXML_TYPE_REAL</code>) nodes are created using the <a href="#mxmlNewReal">mxmlNewReal</a> function and set using the <a href="#mxmlSetReal">mxmlSetReal</a> function:</p>
<pre><code class="language-c">mxml_node_t *
mxmlNewReal(mxml_node_t *parent, <span class="reserved">double</span> real);

<span class="reserved">void</span>
mxmlSetReal(mxml_node_t *node, <span class="reserved">double</span> real);
</code></pre>
<h3 class="title" id="text-nodes">Text Nodes</h3>
<p>Whitespace-delimited text string (<code>MXML_TYPE_TEXT</code>) nodes are created using the <a href="#mxmlNewText">mxmlNewText</a> and <a href="#mxmlNewTextf">mxmlNewTextf</a> functions and set using the <a href="#mxmlSetText">mxmlSetText</a> and <a href="#mxmlSetTextf">mxmlSetTextf</a> functions. Each text node consists of a text string and (leading) whitespace boolean value.</p>
<pre><code class="language-c">mxml_node_t *
mxmlNewText(mxml_node_t *parent, <span class="reserved">bool</span> whitespace,
            <span class="reserved">const</span> <span class="reserved">char</span> *string);

mxml_node_t *
mxmlNewTextf(mxml_node_t *parent, <span class="reserved">bool</span> whitespace,
             <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);

<span class="reserved">void</span>
mxmlSetText(mxml_node_t *node, <span class="reserved">bool</span> whitespace,
            <span class="reserved">const</span> <span class="reserved">char</span> *string);

<span class="reserved">void</span>
mxmlSetTextf(mxml_node_t *node, <span class="reserved">bool</span> whitespace,
             <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);
</code></pre>
<h2 class="title" id="iterating-and-indexing-the-tree">Iterating and Indexing the Tree</h2>
<h3 class="title" id="iterating-nodes">Iterating Nodes</h3>
<p>While the <a href="#mxmlFindNode">mxmlFindNode</a> and <a href="#mxmlFindPath">mxmlFindPath</a> functions will find a particular element node, sometimes you need to iterate over all nodes. The <a href="#mxmlWalkNext">mxmlWalkNext</a> and <a href="#mxmlWalkPrev">mxmlWalkPrev</a> functions can be used to iterate through the XML node tree:</p>
<pre><code class="language-c">mxml_node_t *
mxmlWalkNext(mxml_node_t *node, mxml_node_t *top,
             <span class="reserved">int</span> descend);

mxml_node_t *
mxmlWalkPrev(mxml_node_t *node, mxml_node_t *top,
             <span class="reserved">int</span> descend);
</code></pre>
<p>Depending on the value of the <code>descend</code> argument, these functions will automatically traverse child, sibling, and parent nodes until the <code>top</code> node is reached. For example, the following code will iterate over all of the nodes in the sample XML document in the <a href="#using-mini-xml">Using Mini-XML</a> chapter:</p>
<pre><code class="language-c">mxml_node_t *node;

<span class="reserved">for</span> (node = xml;
     node != NULL;
     node = mxmlWalkNext(node, xml, MXML_DESCEND_ALL))
{
  ... <span class="reserved">do</span> something ...
}
</code></pre>
<p>The nodes will be returned in the following order:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;data&gt;
&lt;node&gt;
val1
&lt;node&gt;
val2
&lt;node&gt;
val3
&lt;group&gt;
&lt;node&gt;
val4
&lt;node&gt;
val5
&lt;node&gt;
val6
&lt;node&gt;
val7
&lt;node&gt;
val8
</code></pre>
<h3 class="title" id="indexing">Indexing</h3>
<p>The <a href="#mxmlIndexNew">mxmlIndexNew</a> function allows you to create an index of nodes for faster searching and enumeration:</p>
<pre><code class="language-c">mxml_index_t *
mxmlIndexNew(mxml_node_t *node, <span class="reserved">const</span> <span class="reserved">char</span> *element,
             <span class="reserved">const</span> <span class="reserved">char</span> *attr);
</code></pre>
<p>The <code>element</code> and <code>attr</code> arguments control which elements are included in the index. If <code>element</code> is not <code>NULL</code> then only elements with the specified name are added to the index. Similarly, if <code>attr</code> is not <code>NULL</code> then only elements containing the specified attribute are added to the index. The nodes are sorted in the index.</p>
<p>For example, the following code creates an index of all &quot;id&quot; values in an XML document:</p>
<pre><code class="language-c">mxml_index_t *ind = mxmlIndexNew(xml, NULL, <span class="string">&quot;id&quot;</span>);
</code></pre>
<p>Once the index is created, the <a href="#mxmlIndexFind">mxmlIndexFind</a> function can be used to find a matching node:</p>
<pre><code class="language-c">mxml_node_t *
mxmlIndexFind(mxml_index_t *ind, <span class="reserved">const</span> <span class="reserved">char</span> *element,
              <span class="reserved">const</span> <span class="reserved">char</span> *value);
</code></pre>
<p>For example, the following code will find the element whose &quot;id&quot; string is &quot;42&quot;:</p>
<pre><code class="language-c">mxml_node_t *node = mxmlIndexFind(ind, NULL, <span class="string">&quot;42&quot;</span>);
</code></pre>
<p>Alternately, the <a href="#mxmlIndexReset">mxmlIndexReset</a> and <a href="#mxmlIndexEnum">mxmlIndexEnum</a> functions can be used to enumerate the nodes in the index:</p>
<pre><code class="language-c">mxml_node_t *
mxmlIndexReset(mxml_index_t *ind);

mxml_node_t *
mxmlIndexEnum(mxml_index_t *ind);
</code></pre>
<p>Typically these functions will be used in a <code>for</code> loop:</p>
<pre><code class="language-c">mxml_node_t *node;

<span class="reserved">for</span> (node = mxmlIndexReset(ind);
     node != NULL;
     node = mxmlIndexEnum(ind))
{
  ... <span class="reserved">do</span> something ...
}
</code></pre>
<p>The <a href="#mxmlIndexCount">mxmlIndexCount</a> function returns the number of nodes in the index:</p>
<pre><code class="language-c">size_t
mxmlIndexGetCount(mxml_index_t *ind);
</code></pre>
<p>Finally, the <a href="#mxmlIndexDelete">mxmlIndexDelete</a> function frees all memory associated with the index:</p>
<pre><code class="language-c"><span class="reserved">void</span>
mxmlIndexDelete(mxml_index_t *ind);
</code></pre>
<h2 class="title" id="advanced-usage">Advanced Usage</h2>
<h3 class="title" id="custom-data-types">Custom Data Types</h3>
<p>Mini-XML supports custom data types via load and save callback options. Only a single set of callbacks can be active at any time for a <code>mxml_options_t</code> pointer, however your callbacks can store additional information in order to support multiple custom data types as needed. The <code>MXML_TYPE_CUSTOM</code> node type identifies custom data nodes.</p>
<p>The <a href="#mxmlGetCustom">mxmlGetCustom</a> function retrieves the custom value pointer for a node.</p>
<pre><code class="language-c"><span class="reserved">const</span> <span class="reserved">void</span> *
mxmlGetCustom(mxml_node_t *node);
</code></pre>
<p>Custom (<code>MXML_TYPE_CUSTOM</code>) nodes are created using the <a href="#mxmlNewCustom">mxmlNewCustom</a> function or using the custom load callback specified using the <a href="#mxmlOptionsSetCustomCallbacks">mxmlOptionsSetCustomCallbacks</a> function:</p>
<pre><code class="language-c"><span class="reserved">typedef</span> <span class="reserved">void</span> (*mxml_custfree_cb_t)(<span class="reserved">void</span> *cbdata, <span class="reserved">void</span> *data);
<span class="reserved">typedef</span> <span class="reserved">bool</span> (*mxml_custload_cb_t)(<span class="reserved">void</span> *cbdata, mxml_node_t *, <span class="reserved">const</span> <span class="reserved">char</span> *);
<span class="reserved">typedef</span> <span class="reserved">char</span> *(*mxml_custsave_cb_t)(<span class="reserved">void</span> *cbdata, mxml_node_t *);

mxml_node_t *
mxmlNewCustom(mxml_node_t *parent, <span class="reserved">void</span> *data,
              mxml_custfree_cb_t free_cb, <span class="reserved">void</span> *free_cbdata);

<span class="reserved">int</span>
mxmlSetCustom(mxml_node_t *node, <span class="reserved">void</span> *data,
              mxml_custfree_cb_t free_cb, <span class="reserved">void</span> *free_cbdata);

<span class="reserved">void</span>
mxmlOptionsSetCustomCallbacks(mxml_option_t *options,
                              mxml_custload_cb_t load_cb,
                              mxml_custsave_cb_t save_cb,
                              <span class="reserved">void</span> *cbdata);
</code></pre>
<p>The load callback receives the callback data pointer, a pointer to the current data node, and a string of opaque character data from the XML source with character entities converted to the corresponding UTF-8 characters. For example, if we wanted to support a custom date/time type whose value is encoded as &quot;yyyy-mm-ddThh:mm:ssZ&quot; (ISO 8601 format), the load callback would look like the following:</p>
<pre><code class="language-c"><span class="reserved">typedef</span> <span class="reserved">struct</span> iso_date_time_s
{
  <span class="reserved">unsigned</span> year,    <span class="comment">/* Year */</span>
           month,   <span class="comment">/* Month */</span>
           day,     <span class="comment">/* Day */</span>
           hour,    <span class="comment">/* Hour */</span>
           minute,  <span class="comment">/* Minute */</span>
           second;  <span class="comment">/* Second */</span>
  time_t   unix;    <span class="comment">/* UNIX time */</span>
} iso_date_time_t;

<span class="reserved">bool</span>
custom_load_cb(<span class="reserved">void</span> *cbdata, mxml_node_t *node, <span class="reserved">const</span> <span class="reserved">char</span> *data)
{
  iso_date_time_t *dt;
  <span class="reserved">struct</span> tm tmdata;

 <span class="comment">/*</span>
<span class="comment">  * Allocate data structure...</span>
<span class="comment">  */</span>

  dt = calloc(<span class="number">1</span>, <span class="reserved">sizeof</span>(iso_date_time_t));

 <span class="comment">/*</span>
<span class="comment">  * Try reading 6 unsigned integers from the data string...</span>
<span class="comment">  */</span>

  <span class="reserved">if</span> (sscanf(data, <span class="string">&quot;%u-%u-%uT%u:%u:%uZ&quot;</span>, &amp;(dt-&gt;year),
             &amp;(dt-&gt;month), &amp;(dt-&gt;day), &amp;(dt-&gt;hour),
             &amp;(dt-&gt;minute), &amp;(dt-&gt;second)) != <span class="number">6</span>)
  {
   <span class="comment">/*</span>
<span class="comment">    * Unable to read numbers, free the data structure and</span>
<span class="comment">    * return an error...</span>
<span class="comment">    */</span>

    free(dt);

    <span class="reserved">return</span> (<span class="reserved">false</span>);
  }

 <span class="comment">/*</span>
<span class="comment">  * Range check values...</span>
<span class="comment">  */</span>

  <span class="reserved">if</span> (dt-&gt;month &lt; <span class="number">1</span> || dt-&gt;month &gt; <span class="number">12</span> ||
      dt-&gt;day &lt; <span class="number">1</span> || dt-&gt;day &gt; <span class="number">31</span> ||
      dt-&gt;hour &lt; <span class="number">0</span> || dt-&gt;hour &gt; <span class="number">23</span> ||
      dt-&gt;minute &lt; <span class="number">0</span> || dt-&gt;minute &gt; <span class="number">59</span> ||
      dt-&gt;second &lt; <span class="number">0</span> || dt-&gt;second &gt; <span class="number">60</span>)
  {
   <span class="comment">/*</span>
<span class="comment">    * Date information is out of range...</span>
<span class="comment">    */</span>

    free(dt);

    <span class="reserved">return</span> (<span class="reserved">false</span>);
  }

 <span class="comment">/*</span>
<span class="comment">  * Convert ISO time to UNIX time in seconds...</span>
<span class="comment">  */</span>

  tmdata.tm_year = dt-&gt;year - <span class="number">1900</span>;
  tmdata.tm_mon  = dt-&gt;month - <span class="number">1</span>;
  tmdata.tm_day  = dt-&gt;day;
  tmdata.tm_hour = dt-&gt;hour;
  tmdata.tm_min  = dt-&gt;minute;
  tmdata.tm_sec  = dt-&gt;second;

  dt-&gt;unix = gmtime(&amp;tmdata);

 <span class="comment">/*</span>
<span class="comment">  * Assign custom node data and free callback function/data...</span>
<span class="comment">  */</span>

  mxmlSetCustom(node, data, custom_free_cb, cbdata);

 <span class="comment">/*</span>
<span class="comment">  * Return with no errors...</span>
<span class="comment">  */</span>

  <span class="reserved">return</span> (<span class="reserved">true</span>);
}
</code></pre>
<p>The function itself can return <code>true</code> on success or <code>false</code> if it is unable to decode the custom data or the data contains an error. Custom data nodes contain a <code>void</code> pointer to the allocated custom data for the node and a pointer to a destructor function which will free the custom data when the node is deleted. In this example, we use the standard <code>free</code> function since everything is contained in a single calloc'd block.</p>
<p>The save callback receives the node pointer and returns an allocated string containing the custom data value. The following save callback could be used for our ISO date/time type:</p>
<pre><code class="language-c"><span class="reserved">char</span> *
custom_save_cb(<span class="reserved">void</span> *cbdata, mxml_node_t *node)
{
  <span class="reserved">char</span> data[<span class="number">255</span>];
  iso_date_time_t *dt;


  dt = (iso_date_time_t *)mxmlGetCustom(node);

  snprintf(data, <span class="reserved">sizeof</span>(data),
           <span class="string">&quot;%04u-%02u-%02uT%02u:%02u:%02uZ&quot;</span>,
           dt-&gt;year, dt-&gt;month, dt-&gt;day, dt-&gt;hour,
           dt-&gt;minute, dt-&gt;second);

  <span class="reserved">return</span> (strdup(data));
}
</code></pre>
<p>You register these callback functions using the <a href="#mxmlOptionsSetCustomCallbacks">mxmlOptionsSetCustomCallbacks</a> function:</p>
<pre><code class="language-c">mxmlOptionsSetCustomCallbacks(options, custom_load_cb,
                              custom_save_cb, <span class="comment">/*cbdata*/</span>NULL);
</code></pre>
<h3 class="title" id="sax-stream-loading-of-documents">SAX (Stream) Loading of Documents</h3>
<p>Mini-XML supports an implementation of the Simple API for XML (SAX) which allows you to load and process an XML document as a stream of nodes. Aside from allowing you to process XML documents of any size, the Mini-XML implementation also allows you to retain portions of the document in memory for later processing.</p>
<p>The mxmlLoadXxx functions support a SAX option that is enabled by setting a callback function and data pointer with the <a href="#mxmlOptionsSetSAXCallback">mxmlOptionsSetSAXCallback</a> function. The callback function receives the data pointer you supplied, the node, and an event code and returns <code>true</code> to continue processing or <code>false</code> to stop:</p>
<pre><code class="language-c"><span class="reserved">bool</span>
sax_cb(<span class="reserved">void</span> *cbdata, mxml_node_t *node,
       mxml_sax_event_t event)
{
  ... <span class="reserved">do</span> something ...

  <span class="comment">// Continue processing...</span>
  <span class="reserved">return</span> (<span class="reserved">true</span>);
}
</code></pre>
<p>The event will be one of the following:</p>
<ul>
<li><p><code>MXML_SAX_EVENT_CDATA</code>: CDATA was just read.</p>
</li>
<li><p><code>MXML_SAX_EVENT_COMMENT</code>: A comment was just read.</p>
</li>
<li><p><code>MXML_SAX_EVENT_DATA</code>: Data (integer, opaque, real, or text) was just read.</p>
</li>
<li><p><code>MXML_SAX_EVENT_DECLARATION</code>: A declaration was just read.</p>
</li>
<li><p><code>MXML_SAX_EVENT_DIRECTIVE</code>: A processing directive/instruction was just read.</p>
</li>
<li><p><code>MXML_SAX_EVENT_ELEMENT_CLOSE</code> - A close element was just read (<code>&lt;/element&gt;</code>)</p>
</li>
<li><p><code>MXML_SAX_EVENT_ELEMENT_OPEN</code> - An open element was just read (<code>&lt;element&gt;</code>)</p>
</li>
</ul>
<p>Elements are <em>released</em> after the close element is processed. All other nodes are released after they are processed. The SAX callback can <em>retain</em> the node using the <a href="#mxmlRetain">mxmlRetain</a> function. For example, the following SAX callback will retain all nodes, effectively simulating a normal in-memory load:</p>
<pre><code class="language-c"><span class="reserved">bool</span>
sax_cb(<span class="reserved">void</span> *cbdata, mxml_node_t *node, mxml_sax_event_t event)
{
  <span class="reserved">if</span> (event != MXML_SAX_ELEMENT_CLOSE)
    mxmlRetain(node);

  <span class="reserved">return</span> (<span class="reserved">true</span>);
}
</code></pre>
<p>More typically the SAX callback will only retain a small portion of the document that is needed for post-processing. For example, the following SAX callback will retain the title and headings in an XHTML file. It also retains the (parent) elements like <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, and <code>&lt;body&gt;</code>, and processing directives like <code>&lt;?xml ... ?&gt;</code> and declarations like <code>&lt;!DOCTYPE ... &gt;</code>:</p>
<pre><code class="language-c"><span class="reserved">bool</span>
sax_cb(<span class="reserved">void</span> *cbdata, mxml_node_t *node,
       mxml_sax_event_t event)
{
  <span class="reserved">if</span> (event == MXML_SAX_ELEMENT_OPEN)
  {
   <span class="comment">/*</span>
<span class="comment">    * Retain headings and titles...</span>
<span class="comment">    */</span>

    <span class="reserved">const</span> <span class="reserved">char</span> *element = mxmlGetElement(node);

    <span class="reserved">if</span> (!strcmp(element, <span class="string">&quot;html&quot;</span>) ||
        !strcmp(element, <span class="string">&quot;head&quot;</span>) ||
        !strcmp(element, <span class="string">&quot;title&quot;</span>) ||
        !strcmp(element, <span class="string">&quot;body&quot;</span>) ||
        !strcmp(element, <span class="string">&quot;h1&quot;</span>) ||
        !strcmp(element, <span class="string">&quot;h2&quot;</span>) ||
        !strcmp(element, <span class="string">&quot;h3&quot;</span>) ||
        !strcmp(element, <span class="string">&quot;h4&quot;</span>) ||
        !strcmp(element, <span class="string">&quot;h5&quot;</span>) ||
        !strcmp(element, <span class="string">&quot;h6&quot;</span>))
      mxmlRetain(node);
  }
  <span class="reserved">else</span> <span class="reserved">if</span> (event == MXML_SAX_DECLARATION)
    mxmlRetain(node);
  <span class="reserved">else</span> <span class="reserved">if</span> (event == MXML_SAX_DIRECTIVE)
    mxmlRetain(node);
  <span class="reserved">else</span> <span class="reserved">if</span> (event == MXML_SAX_DATA)
  {
    <span class="reserved">if</span> (mxmlGetRefCount(mxmlGetParent(node)) &gt; <span class="number">1</span>)
    {
     <span class="comment">/*</span>
<span class="comment">      * If the parent was retained, then retain this data</span>
<span class="comment">      * node as well.</span>
<span class="comment">      */</span>

      mxmlRetain(node);
    }
  }

  <span class="reserved">return</span> (<span class="reserved">true</span>);
}
</code></pre>
<p>The resulting skeleton document tree can then be searched just like one loaded without the SAX callback function. For example, a filter that reads an XHTML document from stdin and then shows the title and headings in the document would look like:</p>
<pre><code class="language-c">mxml_options_t *options;
mxml_node_t *xml, *title, *body, *heading;

options = mxmlOptionsNew();
mxmlOptionsSetSAXCallback(options, sax_cb,
                          <span class="comment">/*cbdata*/</span>NULL);

xml = mxmlLoadFd(<span class="comment">/*top*/</span>NULL, options, <span class="comment">/*fd*/</span><span class="number">0</span>);

title = mxmlFindElement(doc, doc, <span class="string">&quot;title&quot;</span>, NULL, NULL,
                        MXML_DESCEND_ALL);

<span class="reserved">if</span> (title)
  print_children(title);

body = mxmlFindElement(doc, doc, <span class="string">&quot;body&quot;</span>, NULL, NULL,
                       MXML_DESCEND_ALL);

<span class="reserved">if</span> (body)
{
  <span class="reserved">for</span> (heading = mxmlGetFirstChild(body);
       heading;
       heading = mxmlGetNextSibling(heading))
    print_children(heading);
}

mxmlDelete(xml);
mxmlOptionsDelete(options);
</code></pre>
<p>The <code>print_children</code> function is:</p>
<pre><code class="language-c"><span class="reserved">void</span>
print_children(mxml_node_t *parent)
{
  mxml_node_t *node;
  <span class="reserved">const</span> <span class="reserved">char</span> *text;
  <span class="reserved">bool</span> whitespace;

  <span class="reserved">for</span> (node = mxmlGetFirstChild(parent);
       node != NULL;
       node = mxmlGetNextSibling(node))
  {
    text = mxmlGetText(node, &amp;whitespace);

    <span class="reserved">if</span> (whitespace)
      putchar(<span class="string">' '</span>);

    fputs(text, stdout);
  }

  putchar(<span class="string">'\n'</span>);
}
</code></pre>
<h3 class="title" id="user-data">User Data</h3>
<p>Each node has an associated user data pointer that can be used to store useful information for your application. The memory used by the data pointer is <em>not</em> managed by Mini-XML so it is up to you to free it as necessary.</p>
<p>The <a href="#mxmlSetUserData">mxmlSetUserData</a> function sets any user (application) data associated with the node while the <a href="#mxmlGetUserData">mxmlGetUserData</a> function gets any user (application) data associated with the node:</p>
<pre><code class="language-c"><span class="reserved">void</span> *
mxmlGetUserData(mxml_node_t *node);

<span class="reserved">void</span>
mxmlSetUserData(mxml_node_t *node, <span class="reserved">void</span> *user_data);
</code></pre>
<h3 class="title" id="memory-management">Memory Management</h3>
<p>Nodes support reference counting to manage memory usage. The <a href="#mxmlRetain">mxmlRetain</a> and <a href="#mxmlRelease">mxmlRelease</a> functions increment and decrement a node's reference count, respectively. When the reference count goes to zero, <a href="#mxmlRelease">mxmlRelease</a> calls <a href="#mxmlDelete">mxmlDelete</a> to actually free the memory used by the node tree. New nodes start with a reference count of <code>1</code>. You can get a node's current reference count using the <a href="#mxmlGetRefCount">mxmlGetRefCount</a> function.</p>
<p>Strings can also support different kinds of memory management. The default is to use the standard C library strdup and free functions. To use alternate an alternate mechanism, call the <a href="#mxmlSetStringCallbacks">mxmlSetStringCallbacks</a> function to set string copy and free callbacks. The copy callback receives the callback data pointer and the string to copy, and returns a new string that will persist for the life of the XML data. The free callback receives the callback data pointer and the copied string and potentially frees the memory used for it. For example, the following code implements a simple string pool that eliminates duplicate strings:</p>
<pre><code class="language-c"><span class="reserved">typedef</span> <span class="reserved">struct</span> string_pool_s
{
  size_t num_strings;   <span class="comment">// Number of strings</span>
  size_t alloc_strings; <span class="comment">// Allocated strings</span>
  <span class="reserved">char</span>   **strings;      <span class="comment">// Array of strings</span>
} string_pool_t;

<span class="reserved">char</span> *
copy_string(string_pool_t *pool, <span class="reserved">const</span> <span class="reserved">char</span> *s)
{
  size_t i;     <span class="comment">// Looping var</span>
  <span class="reserved">char</span>   *news; <span class="comment">// Copy of string</span>


  <span class="comment">// See if the string is already in the pool...</span>
  <span class="reserved">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;num_strings; i ++)
  {
    <span class="reserved">if</span> (!strcmp(pool-&gt;strings[i], s))
      <span class="reserved">return</span> (pool-&gt;strings[i]);
  }

  <span class="comment">// Not in the pool, add new string</span>
  <span class="reserved">if</span> (pool-&gt;num_strings &gt;= pool-&gt;alloc_strings)
  {
    <span class="comment">// Expand the string pool...</span>
    <span class="reserved">char</span> **temp; <span class="comment">// New strings array</span>

    temp = realloc(pool-&gt;strings,
                   (pool-&gt;alloc_strings + <span class="number">32</span>) *
                       <span class="reserved">sizeof</span>(<span class="reserved">char</span> *));

    <span class="reserved">if</span> (temp == NULL)
      <span class="reserved">return</span> (NULL);

    pool-&gt;alloc_strings += <span class="number">32</span>;
    pool-&gt;strings = temp;
  }

  <span class="reserved">if</span> ((news = strdup(s)) != NULL)
    pool-&gt;strings[pool-&gt;num_strings ++] = news;

  <span class="reserved">return</span> (news);
}

<span class="reserved">void</span>
free_string(string_pool_t *pool, <span class="reserved">char</span> *s)
{
  <span class="comment">// Do nothing here...</span>
}

<span class="reserved">void</span>
free_all_strings(string_pool_t *pool)
{
  size_t i; <span class="comment">// Looping var</span>


  <span class="reserved">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;num_strings; i ++)
    free(pool-&gt;strings[i]);
  free(pool-&gt;strings);
}

...

<span class="comment">// Setup the string pool...</span>
string_pool_t pool = { <span class="number">0</span>, <span class="number">0</span>, NULL };

mxmlSetStringCallbacks((mxml_strcopy_cb_t)copy_string,
                       (mxml_strfree_cb_t)free_string,
                       &amp;pool);

<span class="comment">// Load an XML file...</span>
mxml_node_t *xml;

xml = mxmlLoadFilename(<span class="comment">/*top*/</span>NULL, <span class="comment">/*options*/</span>NULL,
                       <span class="string">&quot;example.xml&quot;</span>);

<span class="comment">// Process the XML file...</span>
...

<span class="comment">// Free memory used by the XML file...</span>
mxmlDelete(xml);

<span class="comment">// Free all strings in the pool...</span>
free_all_strings(&amp;pool);
</code></pre>
<h2 class="title" id="migrating-from-mini-xml-v3.x">Migrating from Mini-XML v3.x</h2>
<p>The following incompatible API changes were made in Mini-XML v4.0:</p>
<ul>
<li><p>Load and save callbacks and options are now managed using <code>mxml_options_t</code> values.</p>
</li>
<li><p>The mxmlSAXLoadXxx functions have been removed in favor of setting the SAX callback function and data pointers of the <code>mxml_options_t</code> value prior to calling the corresponding mxmlLoadXxx functions.</p>
</li>
<li><p>SAX events are now named <code>MXML_SAX_EVENT_foo</code> instead of <code>MXML_SAX_foo</code>.</p>
</li>
<li><p>SAX callbacks now return a boolean value.</p>
</li>
<li><p>Node types are now named <code>MXML_TYPE_foo</code> instead of <code>MXML_foo</code>.</p>
</li>
<li><p>Descend values are now normalized to <code>MXML_DESCEND_ALL</code>, <code>MXML_DESCEND_FIRST</code>, and <code>MXML_DESCEND_NONE</code>.</p>
</li>
<li><p>Functions that returned <code>0</code> on success and <code>-1</code> on error now return <code>true</code> on success and <code>false</code> on error.</p>
</li>
<li><p>CDATA nodes (&quot;<code>&lt;![CDATA[...]]&gt;</code>&quot;) now have their own type (<code>MXML_TYPE_CDATA</code>).</p>
</li>
<li><p>Comment nodes (&quot;<code>&lt;!-- ... --&gt;</code>&quot;) now have their own type (<code>MXML_TYPE_COMMENT</code>).</p>
</li>
<li><p>Declaration nodes (&quot;<code>&lt;!...&gt;</code>&quot;) now have their own type (<code>MXML_TYPE_DECLARATION</code>).</p>
</li>
<li><p>Element attributes are now cleared with the <a href="#mxmlElementClearAttr">mxmlElementClearAttr</a> function instead of mxmlElementDeleteAttr.</p>
</li>
<li><p>Processing instruction/directive nodes (&quot;<code>&lt;?...?&gt;</code>&quot;) now have their own type (<code>MXML_TYPE_DIRECTIVE</code>).</p>
</li>
<li><p>Integer nodes (<code>MXML_TYPE_INTEGER</code>) now use the <code>long</code> type.</p>
</li>
<li><p>Text nodes (<code>MXML_TYPE_TEXT</code>) now use the <code>bool</code> type for the whitespace value.</p>
</li>
<li><p>Custom node callbacks are now set using the <a href="#mxmlOptionsSetCustomCallbacks">mxmlOptionsSetCustomCallbacks</a> function instead of the thread-global mxmlSetCustomHandlers function.</p>
</li>
</ul>
<h2 class="title"><a id="FUNCTIONS">Functions</a></h2>
<h3 class="function"><a id="mxmlAdd">mxmlAdd</a></h3>
<p class="description">Add a node to a tree.</p>
<p class="code">
<span class="reserved">void</span> mxmlAdd(<a href="#mxml_node_t">mxml_node_t</a> *parent, <a href="#mxml_add_t">mxml_add_t</a> add, <a href="#mxml_node_t">mxml_node_t</a> *child, <a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node</td></tr>
<tr><th>add</th>
<td class="description">Where to add, <code>MXML_ADD_BEFORE</code> or <code>MXML_ADD_AFTER</code></td></tr>
<tr><th>child</th>
<td class="description">Child node for where or <code>MXML_ADD_TO_PARENT</code></td></tr>
<tr><th>node</th>
<td class="description">Node to add</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function adds the specified node <code>node</code> to the parent.  If the <code>child</code>
argument is not <code>NULL</code>, the new node is added before or after the specified
child depending on the value of the <code>add</code> argument.  If the <code>child</code> argument
is <code>NULL</code>, the new node is placed at the beginning of the child list
(<code>MXML_ADD_BEFORE</code>) or at the end of the child list (<code>MXML_ADD_AFTER</code>).</p>
<h3 class="function"><a id="mxmlDelete">mxmlDelete</a></h3>
<p class="description">Delete a node and all of its children.</p>
<p class="code">
<span class="reserved">void</span> mxmlDelete(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to delete</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function deletes the node <code>node</code> and all of its children.  If the
specified node has a parent, this function first removes the node from its
parent using the <a href="#mxmlRemove"><code>mxmlRemove</code></a> function.</p>
<h3 class="function"><a id="mxmlElementClearAttr">mxmlElementClearAttr</a></h3>
<p class="description">Remove an attribute from an element.</p>
<p class="code">
<span class="reserved">void</span> mxmlElementClearAttr(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *name);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Element</td></tr>
<tr><th>name</th>
<td class="description">Attribute name</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function removes the attribute <code>name</code> from the element <code>node</code>.</p>
<h3 class="function"><a id="mxmlElementGetAttr">mxmlElementGetAttr</a></h3>
<p class="description">Get the value of an attribute.</p>
<p class="code">
<span class="reserved">const</span> <span class="reserved">char</span> *mxmlElementGetAttr(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *name);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Element node</td></tr>
<tr><th>name</th>
<td class="description">Name of attribute</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Attribute value or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the value for the attribute <code>name</code> from the element
<code>node</code>.  <code>NULL</code> is returned if the node is not an element or the named
attribute does not exist.</p>
<h3 class="function"><a id="mxmlElementGetAttrByIndex">mxmlElementGetAttrByIndex</a></h3>
<p class="description">Get an attribute by index.</p>
<p class="code">
<span class="reserved">const</span> <span class="reserved">char</span> *mxmlElementGetAttrByIndex(<a href="#mxml_node_t">mxml_node_t</a> *node, size_t idx, <span class="reserved">const</span> <span class="reserved">char</span> **name);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
<tr><th>idx</th>
<td class="description">Attribute index, starting at <code>0</code></td></tr>
<tr><th>name</th>
<td class="description">Attribute name or <code>NULL</code> to not return it</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Attribute value</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function returned the Nth (<code>idx</code>) attribute for element <code>node</code>.  The
attribute name is optionallly returned in the <code>name</code> argument.  <code>NULL</code> is
returned if node is not an element or the specified index is out of range.</p>
<h3 class="function"><a id="mxmlElementGetAttrCount">mxmlElementGetAttrCount</a></h3>
<p class="description">Get the number of element attributes.</p>
<p class="code">
size_t mxmlElementGetAttrCount(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Number of attributes</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function returns the number of attributes for the element <code>node</code>.  <code>0</code>
is returned if the node is not an element or there are no attributes for the
element.</p>
<h3 class="function"><a id="mxmlElementSetAttr">mxmlElementSetAttr</a></h3>
<p class="description">Set an attribute for an element.</p>
<p class="code">
<span class="reserved">void</span> mxmlElementSetAttr(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *name, <span class="reserved">const</span> <span class="reserved">char</span> *value);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Element node</td></tr>
<tr><th>name</th>
<td class="description">Name of attribute</td></tr>
<tr><th>value</th>
<td class="description">Attribute value</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets attribute <code>name</code> to the string <code>value</code> for the element
<code>node</code>.  If the named attribute already exists, the value of the attribute
is replaced by the new string value.  The string value is copied.</p>
<h3 class="function"><a id="mxmlElementSetAttrf">mxmlElementSetAttrf</a></h3>
<p class="description">Set an attribute with a formatted value.</p>
<p class="code">
<span class="reserved">void</span> mxmlElementSetAttrf(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *name, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Element node</td></tr>
<tr><th>name</th>
<td class="description">Name of attribute</td></tr>
<tr><th>format</th>
<td class="description">Printf-style attribute value</td></tr>
<tr><th>...</th>
<td class="description">Additional arguments as needed</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets attribute <code>name</code> to the formatted value of <code>format</code> for
the element <code>node</code>.  If the named attribute already exists, the value of the
attribute is replaced by the new formatted string value.</p>
<h3 class="function"><a id="mxmlFindElement">mxmlFindElement</a></h3>
<p class="description">Find the named element.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlFindElement(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_node_t">mxml_node_t</a> *top, <span class="reserved">const</span> <span class="reserved">char</span> *element, <span class="reserved">const</span> <span class="reserved">char</span> *attr, <span class="reserved">const</span> <span class="reserved">char</span> *value, <a href="#mxml_descend_t">mxml_descend_t</a> descend);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Current node</td></tr>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>element</th>
<td class="description">Element name or <code>NULL</code> for any</td></tr>
<tr><th>attr</th>
<td class="description">Attribute name, or <code>NULL</code> for none</td></tr>
<tr><th>value</th>
<td class="description">Attribute value, or <code>NULL</code> for any</td></tr>
<tr><th>descend</th>
<td class="description">Descend into tree - <code>MXML_DESCEND_ALL</code>, <code>MXML_DESCEND_NONE</code>, or <code>MXML_DESCEND_FIRST</code></td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Element node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function finds the named element <code>element</code> in XML tree <code>top</code> starting at
node <code>node</code>.  The search is constrained by element name <code>element</code>, attribute
name <code>attr</code>, and attribute value <code>value</code> - <code>NULL</code> names or values are treated
as wildcards, so different kinds of searches can be implemented by looking
for all elements of a given name or all elements with a specific attribute.<br>
<br>
The <code>descend</code> argument determines whether the search descends into child
nodes; normally you will use <code>MXML_DESCEND_FIRST</code> for the initial search and
<code>MXML_DESCEND_NONE</code> to find additional direct descendents of the node.</p>
<h3 class="function"><a id="mxmlFindPath">mxmlFindPath</a></h3>
<p class="description">Find a node with the given path.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlFindPath(<a href="#mxml_node_t">mxml_node_t</a> *top, <span class="reserved">const</span> <span class="reserved">char</span> *path);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>path</th>
<td class="description">Path to element</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Found node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function finds a node in XML tree <code>top</code> using a slash-separated list of
element names in <code>path</code>.  The name &quot;<em>" is considered a wildcard for one or
more levels of elements, for example, "foo/one/two", "bar/two/one", "</em>/one&quot;,
and so forth.<br>
<br>
The first child node of the found node is returned if the given node has
children and the first child is a value node.</p>
<h3 class="function"><a id="mxmlGetCDATA">mxmlGetCDATA</a></h3>
<p class="description">Get the value for a CDATA node.</p>
<p class="code">
<span class="reserved">const</span> <span class="reserved">char</span> *mxmlGetCDATA(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">CDATA value or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the string value of a CDATA node.  <code>NULL</code> is returned if
the node is not a CDATA element.</p>
<h3 class="function"><a id="mxmlGetComment">mxmlGetComment</a></h3>
<p class="description">Get the value for a comment node.</p>
<p class="code">
<span class="reserved">const</span> <span class="reserved">char</span> *mxmlGetComment(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Comment value or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the string value of a comment node.  <code>NULL</code> is returned
if the node is not a comment.</p>
<h3 class="function"><a id="mxmlGetCustom">mxmlGetCustom</a></h3>
<p class="description">Get the value for a custom node.</p>
<p class="code">
<span class="reserved">const</span> <span class="reserved">void</span> *mxmlGetCustom(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Custom value or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the binary value of a custom node.  <code>NULL</code> is returned if
the node (or its first child) is not a custom value node.</p>
<h3 class="function"><a id="mxmlGetDeclaration">mxmlGetDeclaration</a></h3>
<p class="description">Get the value for a declaration node.</p>
<p class="code">
<span class="reserved">const</span> <span class="reserved">char</span> *mxmlGetDeclaration(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Declaraction value or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the string value of a declaraction node.  <code>NULL</code> is
returned if the node is not a declaration.</p>
<h3 class="function"><a id="mxmlGetDirective">mxmlGetDirective</a></h3>
<p class="description">Get the value for a processing instruction node.</p>
<p class="code">
<span class="reserved">const</span> <span class="reserved">char</span> *mxmlGetDirective(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Comment value or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the string value of a processing instruction.  <code>NULL</code> is
returned if the node is not a processing instruction.</p>
<h3 class="function"><a id="mxmlGetElement">mxmlGetElement</a></h3>
<p class="description">Get the name for an element node.</p>
<p class="code">
<span class="reserved">const</span> <span class="reserved">char</span> *mxmlGetElement(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Element name or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the name of an element node.  <code>NULL</code> is returned if the
node is not an element node.</p>
<h3 class="function"><a id="mxmlGetFirstChild">mxmlGetFirstChild</a></h3>
<p class="description">Get the first child of a node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlGetFirstChild(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First child or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the first child of a node.  <code>NULL</code> is returned if the node
has no children.</p>
<h3 class="function"><a id="mxmlGetInteger">mxmlGetInteger</a></h3>
<p class="description">Get the integer value from the specified node or its
                     first child.</p>
<p class="code">
<span class="reserved">long</span> mxmlGetInteger(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Integer value or <code>0</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the value of an integer node.  <code>0</code> is returned if the node
(or its first child) is not an integer value node.</p>
<h3 class="function"><a id="mxmlGetLastChild">mxmlGetLastChild</a></h3>
<p class="description">Get the last child of a node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlGetLastChild(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Last child or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the last child of a node.  <code>NULL</code> is returned if the node
has no children.</p>
<h3 class="function"><a id="mxmlGetNextSibling">mxmlGetNextSibling</a></h3>
<p class="description"></p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlGetNextSibling(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Get the next node for the current parent.</p>
<p class="discussion">This function gets the next node for the current parent.  <code>NULL</code> is returned
if this is the last child for the current parent.</p>
<h3 class="function"><a id="mxmlGetOpaque">mxmlGetOpaque</a></h3>
<p class="description">Get an opaque string value for a node or its first child.</p>
<p class="code">
<span class="reserved">const</span> <span class="reserved">char</span> *mxmlGetOpaque(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Opaque string or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the string value of an opaque node.  <code>NULL</code> is returned if
the node (or its first child) is not an opaque value node.</p>
<h3 class="function"><a id="mxmlGetParent">mxmlGetParent</a></h3>
<p class="description">Get the parent node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlGetParent(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Parent node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the parent of a node.  <code>NULL</code> is returned for a root node.</p>
<h3 class="function"><a id="mxmlGetPrevSibling">mxmlGetPrevSibling</a></h3>
<p class="description">Get the previous node for the current parent.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlGetPrevSibling(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Previous node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the previous node for the current parent.  <code>NULL</code> is
returned if this is the first child for the current parent.</p>
<h3 class="function"><a id="mxmlGetReal">mxmlGetReal</a></h3>
<p class="description">Get the real value for a node or its first child.</p>
<p class="code">
<span class="reserved">double</span> mxmlGetReal(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Real value or 0.0</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the value of a real value node.  <code>0.0</code> is returned if the
node (or its first child) is not a real value node.</p>
<h3 class="function"><a id="mxmlGetRefCount">mxmlGetRefCount</a></h3>
<p class="description">Get the current reference (use) count for a node.</p>
<p class="code">
size_t mxmlGetRefCount(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Reference count</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The initial reference count of new nodes is 1. Use the <a href="#mxmlRetain"><code>mxmlRetain</code></a>
and <a href="#mxmlRelease"><code>mxmlRelease</code></a> functions to increment and decrement a node's
reference count.</p>
<h3 class="function"><a id="mxmlGetText">mxmlGetText</a></h3>
<p class="description">Get the text value for a node or its first child.</p>
<p class="code">
<span class="reserved">const</span> <span class="reserved">char</span> *mxmlGetText(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">bool</span> *whitespace);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
<tr><th>whitespace</th>
<td class="description"><code>true</code> if string is preceded by whitespace, <code>false</code> otherwise</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Text string or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the string and whitespace values of a text node.  <code>NULL</code>
and <code>false</code> are returned if the node (or its first child) is not a text node.
The <code>whitespace</code> argument can be <code>NULL</code> if you don't want to know the
whitespace value.<br>
<br>
Note: Text nodes consist of whitespace-delimited words. You will only get
single words of text when reading an XML file with <code>MXML_TYPE_TEXT</code> nodes.
If you want the entire string between elements in the XML file, you MUST read
the XML file with <code>MXML_TYPE_OPAQUE</code> nodes and get the resulting strings
using the <a href="#mxmlGetOpaque"><code>mxmlGetOpaque</code></a> function instead.</p>
<h3 class="function"><a id="mxmlGetType">mxmlGetType</a></h3>
<p class="description">Get the node type.</p>
<p class="code">
<a href="#mxml_type_t">mxml_type_t</a> mxmlGetType(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Type of node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the type of <code>node</code>.  <code>MXML_TYPE_IGNORE</code> is returned if
<code>node</code> is <code>NULL</code>.</p>
<h3 class="function"><a id="mxmlGetUserData">mxmlGetUserData</a></h3>
<p class="description">Get the user data pointer for a node.</p>
<p class="code">
<span class="reserved">void</span> *mxmlGetUserData(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">User data pointer</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function gets the user data pointer associated with <code>node</code>.</p>
<h3 class="function"><a id="mxmlIndexDelete">mxmlIndexDelete</a></h3>
<p class="description">Delete an index.</p>
<p class="code">
<span class="reserved">void</span> mxmlIndexDelete(<a href="#mxml_index_t">mxml_index_t</a> *ind);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>ind</th>
<td class="description">Index to delete</td></tr>
</tbody></table>
<h3 class="function"><a id="mxmlIndexEnum">mxmlIndexEnum</a></h3>
<p class="description">Return the next node in the index.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlIndexEnum(<a href="#mxml_index_t">mxml_index_t</a> *ind);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>ind</th>
<td class="description">Index to enumerate</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Next node or <code>NULL</code> if there is none</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function returns the next node in index <code>ind</code>.<br>
<br>
You should call <a href="#mxmlIndexReset"><code>mxmlIndexReset</code></a> prior to using this function to get
the first node in the index.  Nodes are returned in the sorted order of the
index.</p>
<h3 class="function"><a id="mxmlIndexFind">mxmlIndexFind</a></h3>
<p class="description">Find the next matching node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlIndexFind(<a href="#mxml_index_t">mxml_index_t</a> *ind, <span class="reserved">const</span> <span class="reserved">char</span> *element, <span class="reserved">const</span> <span class="reserved">char</span> *value);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>ind</th>
<td class="description">Index to search</td></tr>
<tr><th>element</th>
<td class="description">Element name to find, if any</td></tr>
<tr><th>value</th>
<td class="description">Attribute value, if any</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Node or <code>NULL</code> if none found</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function finds the next matching node in index <code>ind</code>.<br>
<br>
You should call <a href="#mxmlIndexReset"><code>mxmlIndexReset</code></a> prior to using this function for
the first time with a particular set of <code>element</code> and <code>value</code>
strings.  Passing <code>NULL</code> for both <code>element</code> and <code>value</code> is equivalent
to calling <a href="#mxmlIndexEnum"><code>mxmlIndexEnum</code></a>.</p>
<h3 class="function"><a id="mxmlIndexGetCount">mxmlIndexGetCount</a></h3>
<p class="description">Get the number of nodes in an index.</p>
<p class="code">
size_t mxmlIndexGetCount(<a href="#mxml_index_t">mxml_index_t</a> *ind);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>ind</th>
<td class="description">Index of nodes</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Number of nodes in index</p>
<h3 class="function"><a id="mxmlIndexNew">mxmlIndexNew</a></h3>
<p class="description">Create a new index.</p>
<p class="code">
<a href="#mxml_index_t">mxml_index_t</a> *mxmlIndexNew(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *element, <span class="reserved">const</span> <span class="reserved">char</span> *attr);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">XML node tree</td></tr>
<tr><th>element</th>
<td class="description">Element to index or <code>NULL</code> for all</td></tr>
<tr><th>attr</th>
<td class="description">Attribute to index or <code>NULL</code> for none</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New index</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function creates a new index for XML tree <code>node</code>.<br>
<br>
The index will contain all nodes that contain the named element and/or
attribute.  If both <code>element</code> and <code>attr</code> are <code>NULL</code>, then the index will
contain a sorted list of the elements in the node tree.  Nodes are
sorted by element name and optionally by attribute value if the <code>attr</code>
argument is not <code>NULL</code>.</p>
<h3 class="function"><a id="mxmlIndexReset">mxmlIndexReset</a></h3>
<p class="description">Reset the enumeration/find pointer in the index and
                     return the first node in the index.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlIndexReset(<a href="#mxml_index_t">mxml_index_t</a> *ind);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>ind</th>
<td class="description">Index to reset</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if there is none</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function resets the enumeration/find pointer in index <code>ind</code> and should
be called prior to using <a href="#mxmlIndexEnum"><code>mxmlIndexEnum</code></a> or <a href="#mxmlIndexFind"><code>mxmlIndexFind</code></a> for the
first time.</p>
<h3 class="function"><a id="mxmlLoadFd">mxmlLoadFd</a></h3>
<p class="description">Load a file descriptor into an XML node tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlLoadFd(<a href="#mxml_node_t">mxml_node_t</a> *top, <a href="#mxml_options_t">mxml_options_t</a> *options, <span class="reserved">int</span> fd);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>fd</th>
<td class="description">File descriptor to read from</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if the file could not be read.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function loads the file descriptor <code>fd</code> into an XML node tree.  The
nodes in the specified file are added to the specified node <code>top</code> - if <code>NULL</code>
the XML file MUST be well-formed with a single parent processing instruction
node like <code>&lt;?xml version="1.0"?&gt;</code> at the start of the file.<br>
<br>
Load options are provides via the <code>options</code> argument.  If <code>NULL</code>, all values
will be loaded into <code>MXML_TYPE_TEXT</code> nodes.  Use the <a href="#mxmlOptionsNew"><code>mxmlOptionsNew</code></a>
function to create options when loading XML data.</p>
<h3 class="function"><a id="mxmlLoadFile">mxmlLoadFile</a></h3>
<p class="description">Load a file into an XML node tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlLoadFile(<a href="#mxml_node_t">mxml_node_t</a> *top, <a href="#mxml_options_t">mxml_options_t</a> *options, FILE *fp);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>fp</th>
<td class="description">File to read from</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if the file could not be read.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function loads the <code>FILE</code> pointer <code>fp</code> into an XML node tree.  The
nodes in the specified file are added to the specified node <code>top</code> - if <code>NULL</code>
the XML file MUST be well-formed with a single parent processing instruction
node like <code>&lt;?xml version="1.0"?&gt;</code> at the start of the file.<br>
<br>
Load options are provides via the <code>options</code> argument.  If <code>NULL</code>, all values
will be loaded into <code>MXML_TYPE_TEXT</code> nodes.  Use the <a href="#mxmlOptionsNew"><code>mxmlOptionsNew</code></a>
function to create options when loading XML data.</p>
<h3 class="function"><a id="mxmlLoadFilename">mxmlLoadFilename</a></h3>
<p class="description">Load a file into an XML node tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlLoadFilename(<a href="#mxml_node_t">mxml_node_t</a> *top, <a href="#mxml_options_t">mxml_options_t</a> *options, <span class="reserved">const</span> <span class="reserved">char</span> *filename);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>filename</th>
<td class="description">File to read from</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if the file could not be read.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function loads the named file <code>filename</code> into an XML node tree.  The
nodes in the specified file are added to the specified node <code>top</code> - if <code>NULL</code>
the XML file MUST be well-formed with a single parent processing instruction
node like <code>&lt;?xml version="1.0"?&gt;</code> at the start of the file.<br>
<br>
Load options are provides via the <code>options</code> argument.  If <code>NULL</code>, all values
will be loaded into <code>MXML_TYPE_TEXT</code> nodes.  Use the <a href="#mxmlOptionsNew"><code>mxmlOptionsNew</code></a>
function to create options when loading XML data.</p>
<h3 class="function"><a id="mxmlLoadIO">mxmlLoadIO</a></h3>
<p class="description">Load an XML node tree using a read callback.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlLoadIO(<a href="#mxml_node_t">mxml_node_t</a> *top, <a href="#mxml_options_t">mxml_options_t</a> *options, <a href="#mxml_io_cb_t">mxml_io_cb_t</a> io_cb, <span class="reserved">void</span> *io_cbdata);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>io_cb</th>
<td class="description">Read callback function</td></tr>
<tr><th>io_cbdata</th>
<td class="description">Read callback data</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if the file could not be read.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function loads data into an XML node tree using a read callback.  The
nodes in the specified file are added to the specified node <code>top</code> - if <code>NULL</code>
the XML file MUST be well-formed with a single parent processing instruction
node like <code>&lt;?xml version="1.0"?&gt;</code> at the start of the file.<br>
<br>
Load options are provides via the <code>options</code> argument.  If <code>NULL</code>, all values
will be loaded into <code>MXML_TYPE_TEXT</code> nodes.  Use the <a href="#mxmlOptionsNew"><code>mxmlOptionsNew</code></a>
function to create options when loading XML data.<br>
<br>
The read callback function <code>io_cb</code> is called to read a number of bytes from
the source.  The callback data pointer <code>io_cbdata</code> is passed to the read
callback with a pointer to a buffer and the maximum number of bytes to read,
for example:<br>
<br>
<code>`</code>c
size_t my_io_cb(void <em>cbdata, void </em>buffer, size_t bytes)
{
  ... copy up to &quot;bytes&quot; bytes into buffer ...
  ... return the number of bytes &quot;read&quot; or 0 on error ...
}
<code>`</code></p>
<h3 class="function"><a id="mxmlLoadString">mxmlLoadString</a></h3>
<p class="description">Load a string into an XML node tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlLoadString(<a href="#mxml_node_t">mxml_node_t</a> *top, <a href="#mxml_options_t">mxml_options_t</a> *options, <span class="reserved">const</span> <span class="reserved">char</span> *s);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>s</th>
<td class="description">String to load</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if the string has errors.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function loads the string into an XML node tree.  The nodes in the
specified file are added to the specified node <code>top</code> - if <code>NULL</code> the XML file
MUST be well-formed with a single parent processing instruction node like
<code>&lt;?xml version="1.0"?&gt;</code> at the start of the file.<br>
<br>
Load options are provides via the <code>options</code> argument.  If <code>NULL</code>, all values
will be loaded into <code>MXML_TYPE_TEXT</code> nodes.  Use the <a href="#mxmlOptionsNew"><code>mxmlOptionsNew</code></a>
function to create options when loading XML data.</p>
<h3 class="function"><a id="mxmlNewCDATA">mxmlNewCDATA</a></h3>
<p class="description">Create a new CDATA node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewCDATA(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">const</span> <span class="reserved">char</span> *data);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>data</th>
<td class="description">Data string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new CDATA node is added to the end of the specified parent's child
list.  The constant <code>NULL</code> can be used to specify that the new CDATA node
has no parent.  The data string must be nul-terminated and is copied into the
new node.</p>
<h3 class="function"><a id="mxmlNewCDATAf">mxmlNewCDATAf</a></h3>
<p class="description">Create a new formatted CDATA node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewCDATAf(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional args as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new CDATA node is added to the end of the specified parent's child list.
The constant <code>NULL</code> can be used to specify that the new opaque string node
has no parent.  The format string must be nul-terminated and is formatted
into the new node.</p>
<h3 class="function"><a id="mxmlNewComment">mxmlNewComment</a></h3>
<p class="description">Create a new comment node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewComment(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">const</span> <span class="reserved">char</span> *comment);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>comment</th>
<td class="description">Comment string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new comment node is added to the end of the specified parent's child
list.  The constant <code>NULL</code> can be used to specify that the new comment node
has no parent.  The comment string must be nul-terminated and is copied into
the new node.</p>
<h3 class="function"><a id="mxmlNewCommentf">mxmlNewCommentf</a></h3>
<p class="description">Create a new formatted comment string node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewCommentf(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional args as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new comment string node is added to the end of the specified parent's
child list.  The constant <code>NULL</code> can be used to specify that the new opaque
string node has no parent.  The format string must be nul-terminated and is
formatted into the new node.</p>
<h3 class="function"><a id="mxmlNewCustom">mxmlNewCustom</a></h3>
<p class="description">Create a new custom data node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewCustom(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">void</span> *data, <a href="#mxml_custfree_cb_t">mxml_custfree_cb_t</a> free_cb, <span class="reserved">void</span> *free_cbdata);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>data</th>
<td class="description">Pointer to data</td></tr>
<tr><th>free_cb</th>
<td class="description">Free callback function or <code>NULL</code> if none needed</td></tr>
<tr><th>free_cbdata</th>
<td class="description">Free callback data</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new custom node is added to the end of the specified parent's child
list.  The <code>free_cb</code> argument specifies a function to call to free the custom
data when the node is deleted.</p>
<h3 class="function"><a id="mxmlNewDeclaration">mxmlNewDeclaration</a></h3>
<p class="description">Create a new declaraction node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewDeclaration(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">const</span> <span class="reserved">char</span> *declaration);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>declaration</th>
<td class="description">Declaration string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new declaration node is added to the end of the specified parent's child
list.  The constant <code>NULL</code> can be used to specify that the new
declaration node has no parent.  The declaration string must be nul-
terminated and is copied into the new node.</p>
<h3 class="function"><a id="mxmlNewDeclarationf">mxmlNewDeclarationf</a></h3>
<p class="description">Create a new formatted declaration node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewDeclarationf(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional args as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new declaration node is added to the end of the specified parent's
child list.  The constant <code>NULL</code> can be used to specify that
the new opaque string node has no parent.  The format string must be
nul-terminated and is formatted into the new node.</p>
<h3 class="function"><a id="mxmlNewDirective">mxmlNewDirective</a></h3>
<p class="description">Create a new processing instruction node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewDirective(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">const</span> <span class="reserved">char</span> *directive);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>directive</th>
<td class="description">Directive string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new processing instruction node is added to the end of the specified
parent's child list.  The constant <code>NULL</code> can be used to specify that the new
processing instruction node has no parent.  The data string must be
nul-terminated and is copied into the new node.</p>
<h3 class="function"><a id="mxmlNewDirectivef">mxmlNewDirectivef</a></h3>
<p class="description">Create a new formatted processing instruction node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewDirectivef(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional args as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new processing instruction node is added to the end of the specified
parent's child list.  The constant <code>NULL</code> can be used to specify that the new
opaque string node has no parent.  The format string must be
nul-terminated and is formatted into the new node.</p>
<h3 class="function"><a id="mxmlNewElement">mxmlNewElement</a></h3>
<p class="description">Create a new element node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewElement(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">const</span> <span class="reserved">char</span> *name);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>name</th>
<td class="description">Name of element</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new element node is added to the end of the specified parent's child
list. The constant <code>NULL</code> can be used to specify that the new element node
has no parent.</p>
<h3 class="function"><a id="mxmlNewInteger">mxmlNewInteger</a></h3>
<p class="description">Create a new integer node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewInteger(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">long</span> integer);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>integer</th>
<td class="description">Integer value</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new integer node is added to the end of the specified parent's child
list. The constant <code>NULL</code> can be used to specify that the new integer node
has no parent.</p>
<h3 class="function"><a id="mxmlNewOpaque">mxmlNewOpaque</a></h3>
<p class="description">Create a new opaque string.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewOpaque(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">const</span> <span class="reserved">char</span> *opaque);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>opaque</th>
<td class="description">Opaque string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new opaque string node is added to the end of the specified parent's
child list.  The constant <code>NULL</code> can be used to specify that the new opaque
string node has no parent.  The opaque string must be nul-terminated and is
copied into the new node.</p>
<h3 class="function"><a id="mxmlNewOpaquef">mxmlNewOpaquef</a></h3>
<p class="description">Create a new formatted opaque string node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewOpaquef(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional args as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new opaque string node is added to the end of the specified parent's
child list.  The constant <code>NULL</code> can be used to specify that the new opaque
string node has no parent.  The format string must be nul-terminated and is
formatted into the new node.</p>
<h3 class="function"><a id="mxmlNewReal">mxmlNewReal</a></h3>
<p class="description">Create a new real number node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewReal(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">double</span> real);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>real</th>
<td class="description">Real number value</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new real number node is added to the end of the specified parent's
child list.  The constant <code>NULL</code> can be used to specify that the new real
number node has no parent.</p>
<h3 class="function"><a id="mxmlNewText">mxmlNewText</a></h3>
<p class="description">Create a new text fragment node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewText(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">bool</span> whitespace, <span class="reserved">const</span> <span class="reserved">char</span> *string);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>whitespace</th>
<td class="description"><code>true</code> = leading whitespace, <code>false</code> = no whitespace</td></tr>
<tr><th>string</th>
<td class="description">String</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new text node is added to the end of the specified parent's child
list.  The constant <code>NULL</code> can be used to specify that the new text node has
no parent.  The whitespace parameter is used to specify whether leading
whitespace is present before the node.  The text string must be
nul-terminated and is copied into the new node.</p>
<h3 class="function"><a id="mxmlNewTextf">mxmlNewTextf</a></h3>
<p class="description">Create a new formatted text fragment node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewTextf(<a href="#mxml_node_t">mxml_node_t</a> *parent, <span class="reserved">bool</span> whitespace, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>NULL</code></td></tr>
<tr><th>whitespace</th>
<td class="description"><code>true</code> = leading whitespace, <code>false</code> = no whitespace</td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional args as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new text node is added to the end of the specified parent's child
list.  The constant <code>NULL</code> can be used to specify that the new text node has
no parent.  The whitespace parameter is used to specify whether leading
whitespace is present before the node.  The format string must be
nul-terminated and is formatted into the new node.</p>
<h3 class="function"><a id="mxmlNewXML">mxmlNewXML</a></h3>
<p class="description">Create a new XML document tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewXML(<span class="reserved">const</span> <span class="reserved">char</span> *version);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>version</th>
<td class="description">Version number to use</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New ?xml node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The &quot;version&quot; argument specifies the version number to put in the
?xml directive node. If <code>NULL</code>, version &quot;1.0&quot; is assumed.</p>
<h3 class="function"><a id="mxmlOptionsDelete">mxmlOptionsDelete</a></h3>
<p class="description">Free load/save options.</p>
<p class="code">
<span class="reserved">void</span> mxmlOptionsDelete(<a href="#mxml_options_t">mxml_options_t</a> *options);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>options</th>
<td class="description">Options</td></tr>
</tbody></table>
<h3 class="function"><a id="mxmlOptionsNew">mxmlOptionsNew</a></h3>
<p class="description">Allocate load/save options.</p>
<p class="code">
<a href="#mxml_options_t">mxml_options_t</a> *mxmlOptionsNew(<span class="reserved">void</span>);</p>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Options</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function creates a new set of load/save options to use with the
<a href="#mxmlLoadFd"><code>mxmlLoadFd</code></a>, <a href="#mxmlLoadFile"><code>mxmlLoadFile</code></a>, <a href="#mxmlLoadFilename"><code>mxmlLoadFilename</code></a>,
<a href="#mxmlLoadIO"><code>mxmlLoadIO</code></a>, <a href="#mxmlLoadString"><code>mxmlLoadString</code></a>, <a href="#mxmlSaveAllocString"><code>mxmlSaveAllocString</code></a>,
<a href="#mxmlSaveFd"><code>mxmlSaveFd</code></a>, <a href="#mxmlSaveFile"><code>mxmlSaveFile</code></a>, <a href="#mxmlSaveFilename"><code>mxmlSaveFilename</code></a>,
<a href="#mxmlSaveIO"><code>mxmlSaveIO</code></a>, and <a href="#mxmlSaveString"><code>mxmlSaveString</code></a> functions.  Options can be
reused for multiple calls to these functions and should be freed using the
<a href="#mxmlOptionsDelete"><code>mxmlOptionsDelete</code></a> function.<br>
<br>
The default load/save options load values using the constant type
<code>MXML_TYPE_TEXT</code> and save XML data with a wrap margin of 72 columns.
The various <code>mxmlOptionsSet</code> functions are used to change the defaults,
for example:

<pre>
mxml_options_t *options = mxmlOptionsNew();

/* Load values as opaque strings */
mxmlOptionsSetTypeValue(options, MXML_TYPE_OPAQUE);
</pre>

Note: The most common programming error when using the Mini-XML library is
to load an XML file using the <code>MXML_TYPE_TEXT</code> node type, which returns
inline text as a series of whitespace-delimited words, instead of using the
<code>MXML_TYPE_OPAQUE</code> node type which returns the inline text as a single string
(including whitespace).</p>
<h3 class="function"><a id="mxmlOptionsSetCustomCallbacks">mxmlOptionsSetCustomCallbacks</a></h3>
<p class="description">Set the custom data callbacks.</p>
<p class="code">
<span class="reserved">void</span> mxmlOptionsSetCustomCallbacks(<a href="#mxml_options_t">mxml_options_t</a> *options, <a href="#mxml_custload_cb_t">mxml_custload_cb_t</a> load_cb, <a href="#mxml_custsave_cb_t">mxml_custsave_cb_t</a> save_cb, <span class="reserved">void</span> *cbdata);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>load_cb</th>
<td class="description">Custom load callback function</td></tr>
<tr><th>save_cb</th>
<td class="description">Custom save callback function</td></tr>
<tr><th>cbdata</th>
<td class="description">Custom callback data</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the callbacks that are used for loading and saving custom
data types. The load callback <code>load_cb</code> accepts the callback data pointer
<code>cbdata</code>, a node pointer, and a data string and returns <code>true</code> on success and
<code>false</code> on error, for example:<br>
<br>
<code>`</code>c
typedef struct
{
  unsigned year,    /<em> Year </em>/
           month,   /<em> Month </em>/
           day,     /<em> Day </em>/
           hour,    /<em> Hour </em>/
           minute,  /<em> Minute </em>/
           second;  /<em> Second </em>/
  time_t   unix;    /<em> UNIX time </em>/
} iso_date_time_t;<br>
<br>
void
my_custom_free_cb(void <em>cbdata, void </em>data)
{
  free(data);
}<br>
<br>
bool
my_custom_load_cb(void <em>cbdata, mxml_node_t </em>node, const char <em>data)
{
  iso_date_time_t </em>dt;
  struct tm tmdata;<br>
<br>
  /<em> Allocate custom data structure ... </em>/
  dt = calloc(1, sizeof(iso_date_time_t));<br>
<br>
  /<em> Parse the data string... </em>/
  if (sscanf(data, &quot;%u-%u-%uT%u:%u:%uZ&quot;, &amp;(dt-&gt;year), &amp;(dt-&gt;month),
             &amp;(dt-&gt;day), &amp;(dt-&gt;hour), &amp;(dt-&gt;minute), &amp;(dt-&gt;second)) != 6)
  {
    /<em> Unable to parse date and time numbers... </em>/
    free(dt);
    return (false);
  }<br>
<br>
  /<em> Range check values... </em>/
  if (dt-&gt;month <a href=" 1 || dt-"> 1 || dt-</a>month &gt; 12 || dt-&gt;day <a href=" 1 || dt-"> 1 || dt-</a>day &gt; 31 ||
      dt-&gt;hour <a href=" 0 || dt-"> 0 || dt-</a>hour &gt; 23 || dt-&gt;minute <a href=" 0 || dt-"> 0 || dt-</a>minute &gt; 59 ||
      dt-&gt;second <a href=" 0 || dt-"> 0 || dt-</a>second &gt; 60)
  {
    /<em> Date information is out of range... </em>/
    free(dt);
    return (false);
  }<br>
<br>
  /<em> Convert ISO time to UNIX time in seconds... </em>/
  tmdata.tm_year = dt-&gt;year - 1900;
  tmdata.tm_mon  = dt-&gt;month - 1;
  tmdata.tm_day  = dt-&gt;day;
  tmdata.tm_hour = dt-&gt;hour;
  tmdata.tm_min  = dt-&gt;minute;
  tmdata.tm_sec  = dt-&gt;second;<br>
<br>
  dt-&gt;unix = gmtime(&amp;tmdata);<br>
<br>
  /<em> Set custom data and free function... </em>/
  mxmlSetCustom(node, data, my_custom_free, /<em>cbdata</em>/NULL);<br>
<br>
  /<em> Return with no errors... </em>/
  return (true);
}
<pre>

The save callback `save_cb` accepts the callback data pointer `cbdata` and a
node pointer and returns a malloc'd string on success and `NULL` on error,
for example:

```c
char *
my_custom_save_cb(void *cbdata, mxml_node_t *node)
{
  char data[255];
  iso_date_time_t *dt;

  /* Get the custom data structure */
  dt = (iso_date_time_t *)mxmlGetCustom(node);

  /* Generate string version of the date/time... */
  snprintf(data, sizeof(data), &quot;%04u-%02u-%02uT%02u:%02u:%02uZ&quot;,
           dt-&gt;year, dt-&gt;month, dt-&gt;day, dt-&gt;hour, dt-&gt;minute, dt-&gt;second);

  /* Duplicate the string and return... */
  return (strdup(data));
}
</pre>
</p>
<h3 class="function"><a id="mxmlOptionsSetEntityCallback">mxmlOptionsSetEntityCallback</a></h3>
<p class="description">Set the entity lookup callback to use when loading XML data.</p>
<p class="code">
<span class="reserved">void</span> mxmlOptionsSetEntityCallback(<a href="#mxml_options_t">mxml_options_t</a> *options, <a href="#mxml_entity_cb_t">mxml_entity_cb_t</a> cb, <span class="reserved">void</span> *cbdata);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>cb</th>
<td class="description">Entity callback function</td></tr>
<tr><th>cbdata</th>
<td class="description">Entity callback data</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the callback that is used to lookup named XML character
entities when loading XML data.  The callback function <code>cb</code> accepts the
callback data pointer <code>cbdata</code> and the entity name.  The function returns a
Unicode character value or <code>-1</code> if the entity is not known.  For example, the
following entity callback supports the &quot;euro&quot; entity:<br>
<br>
<code>`</code>c
int my_entity_cb(void <em>cbdata, const char </em>name)
{
  if (!strcmp(name, &quot;euro&quot;))
    return (0x20ac);
  else
    return (-1);
}
<pre>

Mini-XML automatically supports the &quot;amp&quot;, &quot;gt&quot;, &quot;lt&quot;, and &quot;quot&quot; character
entities which are required by the base XML specification.</pre>
 char *data)
{
  iso_date_time_t </p>
<h3 class="function"><a id="mxmlOptionsSetErrorCallback">mxmlOptionsSetErrorCallback</a></h3>
<p class="description">Set the error message callback.</p>
<p class="code">
<span class="reserved">void</span> mxmlOptionsSetErrorCallback(<a href="#mxml_options_t">mxml_options_t</a> *options, <a href="#mxml_error_cb_t">mxml_error_cb_t</a> cb, <span class="reserved">void</span> *cbdata);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>cb</th>
<td class="description">Error callback function</td></tr>
<tr><th>cbdata</th>
<td class="description">Error callback data</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets a function to use when reporting errors.  The callback
<code>cb</code> accepts the data pointer <code>cbdata</code> and a string pointer containing the
error message:<br>
<br>
<code>`</code>c
void my_error_cb(void <em>cbdata, const char </em>message)
{
  fprintf(stderr, &quot;myprogram: %sn&quot;, message);
}
<pre>

The default error callback writes the error message to the `stderr` file.</pre>
ack supports the &quot;euro&quot; entity:<br>
<br>
<code>`</code></p>
<h3 class="function"><a id="mxmlOptionsSetSAXCallback">mxmlOptionsSetSAXCallback</a></h3>
<p class="description">Set the SAX callback to use when reading XML data.</p>
<p class="code">
<span class="reserved">void</span> mxmlOptionsSetSAXCallback(<a href="#mxml_options_t">mxml_options_t</a> *options, <a href="#mxml_sax_cb_t">mxml_sax_cb_t</a> cb, <span class="reserved">void</span> *cbdata);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>cb</th>
<td class="description">SAX callback function</td></tr>
<tr><th>cbdata</th>
<td class="description">SAX callback data</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets a SAX callback to use when reading XML data.  The SAX
callback function <code>cb</code> and associated callback data <code>cbdata</code> are used to
enable the Simple API for XML streaming mode.  The callback is called as the
XML node tree is parsed and receives the <code>cbdata</code> pointer, the <code>mxml_node_t</code>
pointer, and an event code.  The function returns <code>true</code> to continue
processing or <code>false</code> to stop:<br>
<br>
<code>`</code>c
bool
sax_cb(void <em>cbdata, mxml_node_t </em>node,
       mxml_sax_event_t event)
{
  ... do something ...<br>
<br>
  /<em> Continue processing... </em>/
  return (true);
}
<pre>

The event will be one of the following:

- `MXML_SAX_EVENT_CDATA`: CDATA was just read.
- `MXML_SAX_EVENT_COMMENT`: A comment was just read.
- `MXML_SAX_EVENT_DATA`: Data (integer, opaque, real, or text) was just read.
- `MXML_SAX_EVENT_DECLARATION`: A declaration was just read.
- `MXML_SAX_EVENT_DIRECTIVE`: A processing directive/instruction was just read.
- `MXML_SAX_EVENT_ELEMENT_CLOSE` - A close element was just read (`&lt;/element&gt;`)
- `MXML_SAX_EVENT_ELEMENT_OPEN` - An open element was just read (`&lt;element&gt;`)

Elements are *released* after the close element is processed.  All other nodes
are released after they are processed.  The SAX callback can *retain* the node
using the [mxmlRetain](@@) function.</pre>
 /* Date information is out of range... </p>
<h3 class="function"><a id="mxmlOptionsSetTypeCallback">mxmlOptionsSetTypeCallback</a></h3>
<p class="description">Set the type callback for child/value nodes.</p>
<p class="code">
<span class="reserved">void</span> mxmlOptionsSetTypeCallback(<a href="#mxml_options_t">mxml_options_t</a> *options, <a href="#mxml_type_cb_t">mxml_type_cb_t</a> cb, <span class="reserved">void</span> *cbdata);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>cb</th>
<td class="description">Type callback function</td></tr>
<tr><th>cbdata</th>
<td class="description">Type callback data</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The load callback function <code>cb</code> is called to obtain the node type child/value
nodes and receives the <code>cbdata</code> pointer and the <code>mxml_node_t</code> pointer, for
example:<br>
<br>
<code>`</code>c
mxml_type_t
my_type_cb(void <em>cbdata, mxml_node_t </em>node)
{
  const char <em>type;

 /</em>
  <em> You can lookup attributes and/or use the element name,
  </em> hierarchy, etc...
  */<br>
<br>
  type = mxmlElementGetAttr(node, &quot;type&quot;);
  if (type == NULL)
    type = mxmlGetElement(node);
  if (type == NULL)
    type = &quot;text&quot;;<br>
<br>
  if (!strcmp(type, &quot;integer&quot;))
    return (MXML_TYPE_INTEGER);
  else if (!strcmp(type, &quot;opaque&quot;))
    return (MXML_TYPE_OPAQUE);
  else if (!strcmp(type, &quot;real&quot;))
    return (MXML_TYPE_REAL);
  else
    return (MXML_TYPE_TEXT);
}
<code>`</code></p>
<h3 class="function"><a id="mxmlOptionsSetTypeValue">mxmlOptionsSetTypeValue</a></h3>
<p class="description">Set the type to use for all child/value nodes.</p>
<p class="code">
<span class="reserved">void</span> mxmlOptionsSetTypeValue(<a href="#mxml_options_t">mxml_options_t</a> *options, <a href="#mxml_type_t">mxml_type_t</a> type);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>type</th>
<td class="description">Value node type</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This functions sets a constant node type to use for all child/value nodes.</p>
<h3 class="function"><a id="mxmlOptionsSetWhitespaceCallback">mxmlOptionsSetWhitespaceCallback</a></h3>
<p class="description">Set the whitespace callback.</p>
<p class="code">
<span class="reserved">void</span> mxmlOptionsSetWhitespaceCallback(<a href="#mxml_options_t">mxml_options_t</a> *options, <a href="#mxml_ws_cb_t">mxml_ws_cb_t</a> cb, <span class="reserved">void</span> *cbdata);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>cb</th>
<td class="description">Whitespace callback function</td></tr>
<tr><th>cbdata</th>
<td class="description">Whitespace callback data</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the whitespace callback that is used when saving XML data.
The callback function <code>cb</code> specifies a function that returns a whitespace
string or <code>NULL</code> before and after each element.  The function receives the
callback data pointer <code>cbdata</code>, the <code>mxml_node_t</code> pointer, and a &quot;when&quot;
value indicating where the whitespace is being added, for example:<br>
<br>
<code>`</code>c
const char <em>my_whitespace_cb(void </em>cbdata, mxml_node_t *node, mxml_ws_t when)
{
  if (when == MXML_WS_BEFORE_OPEN || when == MXML_WS_AFTER_CLOSE)
    return (&quot;n&quot;);
  else
    return (NULL);
}
<code>`</code></p>
<h3 class="function"><a id="mxmlOptionsSetWrapMargin">mxmlOptionsSetWrapMargin</a></h3>
<p class="description">Set the wrap margin when saving XML data.</p>
<p class="code">
<span class="reserved">void</span> mxmlOptionsSetWrapMargin(<a href="#mxml_options_t">mxml_options_t</a> *options, <span class="reserved">int</span> column);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>column</th>
<td class="description">Wrap column</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the wrap margin used when saving XML data.  Wrapping is
disabled when <code>column</code> is <code>0</code>.</p>
<h3 class="function"><a id="mxmlRelease">mxmlRelease</a></h3>
<p class="description">Release a node.</p>
<p class="code">
<span class="reserved">int</span> mxmlRelease(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New reference count</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">When the reference count reaches zero, the node (and any children)
is deleted via <a href="#mxmlDelete"><code>mxmlDelete</code></a>.</p>
<h3 class="function"><a id="mxmlRemove">mxmlRemove</a></h3>
<p class="description">Remove a node from its parent.</p>
<p class="code">
<span class="reserved">void</span> mxmlRemove(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to remove</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function does not free memory used by the node - use <a href="#mxmlDelete"><code>mxmlDelete</code></a>
for that.  This function does nothing if the node has no parent.</p>
<h3 class="function"><a id="mxmlRetain">mxmlRetain</a></h3>
<p class="description">Retain a node.</p>
<p class="code">
<span class="reserved">int</span> mxmlRetain(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New reference count</p>
<h3 class="function"><a id="mxmlSaveAllocString">mxmlSaveAllocString</a></h3>
<p class="description">Save an XML tree to an allocated string.</p>
<p class="code">
<span class="reserved">char</span> *mxmlSaveAllocString(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_options_t">mxml_options_t</a> *options);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to write</td></tr>
<tr><th>options</th>
<td class="description">Options</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Allocated string or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function saves the XML tree <code>node</code> to an allocated string.  The string
should be freed using <code>free</code> (or the string free callback set using
<a href="#mxmlSetStringCallbacks"><code>mxmlSetStringCallbacks</code></a>) when you are done with it.<br>
<br>
<code>NULL</code> is returned if the node would produce an empty string or if the string
cannot be allocated.<br>
<br>
Save options are provides via the <code>options</code> argument.  If <code>NULL</code>, the XML
output will be wrapped at column 72 with no additional whitespace.  Use the
<a href="#mxmlOptionsNew"><code>mxmlOptionsNew</code></a> function to create options for saving XML data.</p>
<h3 class="function"><a id="mxmlSaveFd">mxmlSaveFd</a></h3>
<p class="description">Save an XML tree to a file descriptor.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSaveFd(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_options_t">mxml_options_t</a> *options, <span class="reserved">int</span> fd);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to write</td></tr>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>fd</th>
<td class="description">File descriptor to write to</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on error.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function saves the XML tree <code>node</code> to a file descriptor.<br>
<br>
Save options are provides via the <code>options</code> argument.  If <code>NULL</code>, the XML
output will be wrapped at column 72 with no additional whitespace.  Use the
<a href="#mxmlOptionsNew"><code>mxmlOptionsNew</code></a> function to create options for saving XML data.</p>
<h3 class="function"><a id="mxmlSaveFile">mxmlSaveFile</a></h3>
<p class="description">Save an XML tree to a file.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSaveFile(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_options_t">mxml_options_t</a> *options, FILE *fp);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to write</td></tr>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>fp</th>
<td class="description">File to write to</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on error.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function saves the XML tree <code>node</code> to a stdio <code>FILE</code>.<br>
<br>
Save options are provides via the <code>options</code> argument.  If <code>NULL</code>, the XML
output will be wrapped at column 72 with no additional whitespace.  Use the
<a href="#mxmlOptionsNew"><code>mxmlOptionsNew</code></a> function to create options for saving XML data.</p>
<h3 class="function"><a id="mxmlSaveFilename">mxmlSaveFilename</a></h3>
<p class="description">Save an XML tree to a file.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSaveFilename(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_options_t">mxml_options_t</a> *options, <span class="reserved">const</span> <span class="reserved">char</span> *filename);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to write</td></tr>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>filename</th>
<td class="description">File to write to</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on error.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function saves the XML tree <code>node</code> to a named file.<br>
<br>
Save options are provides via the <code>options</code> argument.  If <code>NULL</code>, the XML
output will be wrapped at column 72 with no additional whitespace.  Use the
<a href="#mxmlOptionsNew"><code>mxmlOptionsNew</code></a> function to create options for saving XML data.</p>
<h3 class="function"><a id="mxmlSaveIO">mxmlSaveIO</a></h3>
<p class="description">Save an XML tree using a callback.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSaveIO(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_options_t">mxml_options_t</a> *options, <a href="#mxml_io_cb_t">mxml_io_cb_t</a> io_cb, <span class="reserved">void</span> *io_cbdata);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to write</td></tr>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>io_cb</th>
<td class="description">Write callback function</td></tr>
<tr><th>io_cbdata</th>
<td class="description">Write callback data</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on error.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function saves the XML tree <code>node</code> using a write callback function
<code>io_cb</code>.  The write callback is called with the callback data pointer
<code>io_cbdata</code>, a buffer pointer, and the number of bytes to write, for
example:<br>
<br>
<code>`</code>c
size_t my_io_cb(void <em>cbdata, const void </em>buffer, size_t bytes)
{
  ... write/copy bytes from buffer to the output ...
  ... return the number of bytes written/copied or 0 on error ...
}
<pre>

Save options are provides via the `options` argument.  If `NULL`, the XML
output will be wrapped at column 72 with no additional whitespace.  Use the
@link mxmlOptionsNew@ function to create options for saving XML data.</pre>
, &quot;real&quot;))
    return (MXML_TYPE_REAL);
  else
    return (MXML_TYPE_TEXT);
}
<code>`</code></p>
<h3 class="function"><a id="mxmlSaveString">mxmlSaveString</a></h3>
<p class="description">Save an XML node tree to a string.</p>
<p class="code">
size_t mxmlSaveString(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_options_t">mxml_options_t</a> *options, <span class="reserved">char</span> *buffer, size_t bufsize);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to write</td></tr>
<tr><th>options</th>
<td class="description">Options</td></tr>
<tr><th>buffer</th>
<td class="description">String buffer</td></tr>
<tr><th>bufsize</th>
<td class="description">Size of string buffer</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Size of string</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function saves the XML tree <code>node</code> to a fixed-size string buffer.<br>
<br>
Save options are provides via the <code>options</code> argument.  If <code>NULL</code>, the XML
output will be wrapped at column 72 with no additional whitespace.  Use the
<a href="#mxmlOptionsNew"><code>mxmlOptionsNew</code></a> function to create options for saving XML data.</p>
<h3 class="function"><a id="mxmlSetCDATA">mxmlSetCDATA</a></h3>
<p class="description">Set the data for a CDATA node.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetCDATA(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *data);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>data</th>
<td class="description">New data string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the value string for a CDATA node.  The node is not
changed if it (or its first child) is not a CDATA node.</p>
<h3 class="function"><a id="mxmlSetCDATAf">mxmlSetCDATAf</a></h3>
<p class="description">Set the data for a CDATA to a formatted string.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetCDATAf(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
<tr><th>format</th>
<td class="description"><code>printf</code>-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional arguments as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the formatted string value of a CDATA node.  The node is
not changed if it (or its first child) is not a CDATA node.</p>
<h3 class="function"><a id="mxmlSetComment">mxmlSetComment</a></h3>
<p class="description">Set a comment to a literal string.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetComment(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *comment);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
<tr><th>comment</th>
<td class="description">Literal string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the string value of a comment node.</p>
<h3 class="function"><a id="mxmlSetCommentf">mxmlSetCommentf</a></h3>
<p class="description">Set a comment to a formatted string.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetCommentf(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
<tr><th>format</th>
<td class="description"><code>printf</code>-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional arguments as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the formatted string value of a comment node.</p>
<h3 class="function"><a id="mxmlSetCustom">mxmlSetCustom</a></h3>
<p class="description">Set the data and destructor of a custom data node.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetCustom(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">void</span> *data, <a href="#mxml_custfree_cb_t">mxml_custfree_cb_t</a> free_cb, <span class="reserved">void</span> *free_cbdata);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>data</th>
<td class="description">New data pointer</td></tr>
<tr><th>free_cb</th>
<td class="description">Free callback function</td></tr>
<tr><th>free_cbdata</th>
<td class="description">Free callback data</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the data pointer <code>data</code> and destructor callback
<code>destroy_cb</code> of a custom data node.  The node is not changed if it (or its
first child) is not a custom node.</p>
<h3 class="function"><a id="mxmlSetDeclaration">mxmlSetDeclaration</a></h3>
<p class="description">Set a declaration to a literal string.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetDeclaration(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *declaration);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
<tr><th>declaration</th>
<td class="description">Literal string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the string value of a declaration node.</p>
<h3 class="function"><a id="mxmlSetDeclarationf">mxmlSetDeclarationf</a></h3>
<p class="description">Set a declaration to a formatted string.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetDeclarationf(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
<tr><th>format</th>
<td class="description"><code>printf</code>-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional arguments as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the formatted string value of a declaration node.</p>
<h3 class="function"><a id="mxmlSetDirective">mxmlSetDirective</a></h3>
<p class="description">Set a processing instruction to a literal string.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetDirective(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *directive);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
<tr><th>directive</th>
<td class="description">Literal string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the string value of a processing instruction node.</p>
<h3 class="function"><a id="mxmlSetDirectivef">mxmlSetDirectivef</a></h3>
<p class="description">Set a processing instruction to a formatted string.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetDirectivef(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
<tr><th>format</th>
<td class="description"><code>printf</code>-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional arguments as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the formatted string value of a processing instruction
node.</p>
<h3 class="function"><a id="mxmlSetElement">mxmlSetElement</a></h3>
<p class="description">Set the name of an element node.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetElement(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *name);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>name</th>
<td class="description">New name string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the name of an element node.  The node is not changed if
it is not an element node.</p>
<h3 class="function"><a id="mxmlSetInteger">mxmlSetInteger</a></h3>
<p class="description">Set the value of an integer node.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetInteger(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">long</span> integer);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>integer</th>
<td class="description">Integer value</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the value of an integer node.  The node is not changed if
it (or its first child) is not an integer node.</p>
<h3 class="function"><a id="mxmlSetOpaque">mxmlSetOpaque</a></h3>
<p class="description">Set the value of an opaque node.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetOpaque(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *opaque);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>opaque</th>
<td class="description">Opaque string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the string value of an opaque node.  The node is not
changed if it (or its first child) is not an opaque node.</p>
<h3 class="function"><a id="mxmlSetOpaquef">mxmlSetOpaquef</a></h3>
<p class="description">Set the value of an opaque string node to a formatted string.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetOpaquef(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional arguments as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the formatted string value of an opaque node.  The node is
not changed if it (or its first child) is not an opaque node.</p>
<h3 class="function"><a id="mxmlSetReal">mxmlSetReal</a></h3>
<p class="description">Set the value of a real value node.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetReal(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">double</span> real);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>real</th>
<td class="description">Real number value</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the value of a real value node.  The node is not changed
if it (or its first child) is not a real value node.</p>
<h3 class="function"><a id="mxmlSetText">mxmlSetText</a></h3>
<p class="description">Set the value of a text node.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetText(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">bool</span> whitespace, <span class="reserved">const</span> <span class="reserved">char</span> *string);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>whitespace</th>
<td class="description"><code>true</code> = leading whitespace, <code>false</code> = no whitespace</td></tr>
<tr><th>string</th>
<td class="description">String</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the string and whitespace values of a text node.  The node
is not changed if it (or its first child) is not a text node.</p>
<h3 class="function"><a id="mxmlSetTextf">mxmlSetTextf</a></h3>
<p class="description">Set the value of a text node to a formatted string.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetTextf(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">bool</span> whitespace, <span class="reserved">const</span> <span class="reserved">char</span> *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>whitespace</th>
<td class="description"><code>true</code> = leading whitespace, <code>false</code> = no whitespace</td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional arguments as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function sets the formatted string and whitespace values of a text node.
The node is not changed if it (or its first child) is not a text node.</p>
<h3 class="function"><a id="mxmlSetUserData">mxmlSetUserData</a></h3>
<p class="description">Set the user data pointer for a node.</p>
<p class="code">
<span class="reserved">bool</span> mxmlSetUserData(<a href="#mxml_node_t">mxml_node_t</a> *node, <span class="reserved">void</span> *data);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>data</th>
<td class="description">User data pointer</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"><code>true</code> on success, <code>false</code> on failure</p>
<h3 class="function"><a id="mxmlWalkNext">mxmlWalkNext</a></h3>
<p class="description">Walk to the next logical node in the tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlWalkNext(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_node_t">mxml_node_t</a> *top, <a href="#mxml_descend_t">mxml_descend_t</a> descend);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Current node</td></tr>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>descend</th>
<td class="description">Descend into tree - <code>MXML_DESCEND_ALL</code>, <code>MXML_DESCEND_NONE</code>, or <code>MXML_DESCEND_FIRST</code></td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Next node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function walks to the next logical node in the tree.  The <code>descend</code>
argument controls whether the first child is considered to be the next node.
The <code>top</code> argument constrains the walk to that node's children.</p>
<h3 class="function"><a id="mxmlWalkPrev">mxmlWalkPrev</a></h3>
<p class="description">Walk to the previous logical node in the tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlWalkPrev(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_node_t">mxml_node_t</a> *top, <a href="#mxml_descend_t">mxml_descend_t</a> descend);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Current node</td></tr>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>descend</th>
<td class="description">Descend into tree - <code>MXML_DESCEND_ALL</code>, <code>MXML_DESCEND_NONE</code>, or <code>MXML_DESCEND_FIRST</code></td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Previous node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function walks to the previous logical node in the tree.  The <code>descend</code>
argument controls whether the first child is considered to be the next node.
The <code>top</code> argument constrains the walk to that node's children.</p>
<h2 class="title"><a id="TYPES">Data Types</a></h2>
<h3 class="typedef"><a id="mxml_add_t">mxml_add_t</a></h3>
<p class="description"><a href="#mxmlAdd"><code>mxmlAdd</code></a> add values</p>
<p class="code">
typedef enum <a href="#mxml_add_e">mxml_add_e</a> mxml_add_t;
</p>
<h3 class="typedef"><a id="mxml_custfree_cb_t">mxml_custfree_cb_t</a></h3>
<p class="description">Custom data destructor</p>
<p class="code">
typedef void (*mxml_custfree_cb_t)(void *cbdata void *custdata);
</p>
<h3 class="typedef"><a id="mxml_custload_cb_t">mxml_custload_cb_t</a></h3>
<p class="description">Custom data load callback function</p>
<p class="code">
typedef bool (*mxml_custload_cb_t)(void *cbdata <a href="#mxml_node_t">mxml_node_t</a> *node const char *s);
</p>
<h3 class="typedef"><a id="mxml_custsave_cb_t">mxml_custsave_cb_t</a></h3>
<p class="description">Custom data save callback function</p>
<p class="code">
typedef char *(*mxml_custsave_cb_t)(void *cbdata <a href="#mxml_node_t">mxml_node_t</a> *node);
</p>
<h3 class="typedef"><a id="mxml_descend_t">mxml_descend_t</a></h3>
<p class="description"><a href="#mxmlFindElement"><code>mxmlFindElement</code></a>, <a href="#mxmlWalkNext"><code>mxmlWalkNext</code></a>, and <a href="#mxmlWalkPrev"><code>mxmlWalkPrev</code></a> descend values</p>
<p class="code">
typedef enum <a href="#mxml_descend_e">mxml_descend_e</a> mxml_descend_t;
</p>
<h3 class="typedef"><a id="mxml_entity_cb_t">mxml_entity_cb_t</a></h3>
<p class="description">Entity callback function</p>
<p class="code">
typedef int (*mxml_entity_cb_t)(void *cbdata const char *name);
</p>
<h3 class="typedef"><a id="mxml_error_cb_t">mxml_error_cb_t</a></h3>
<p class="description">Error callback function</p>
<p class="code">
typedef void (*mxml_error_cb_t)(void *cbdata const char *message);
</p>
<h3 class="typedef"><a id="mxml_index_t">mxml_index_t</a></h3>
<p class="description">An XML node index</p>
<p class="code">
typedef struct _mxml_index_s mxml_index_t;
</p>
<h3 class="typedef"><a id="mxml_io_cb_t">mxml_io_cb_t</a></h3>
<p class="description">Read/write callback function</p>
<p class="code">
typedef size_t (*mxml_io_cb_t)(void *cbdata void *buffer size_t bytes);
</p>
<h3 class="typedef"><a id="mxml_node_t">mxml_node_t</a></h3>
<p class="description">An XML node</p>
<p class="code">
typedef struct _mxml_node_s mxml_node_t;
</p>
<h3 class="typedef"><a id="mxml_options_t">mxml_options_t</a></h3>
<p class="description">XML options</p>
<p class="code">
typedef struct _mxml_options_s mxml_options_t;
</p>
<h3 class="typedef"><a id="mxml_sax_cb_t">mxml_sax_cb_t</a></h3>
<p class="description">SAX callback function</p>
<p class="code">
typedef bool (*mxml_sax_cb_t)(void *cbdata <a href="#mxml_node_t">mxml_node_t</a> *node <a href="#mxml_sax_event_t">mxml_sax_event_t</a> event);
</p>
<h3 class="typedef"><a id="mxml_sax_event_t">mxml_sax_event_t</a></h3>
<p class="description">SAX event type.</p>
<p class="code">
typedef enum <a href="#mxml_sax_event_e">mxml_sax_event_e</a> mxml_sax_event_t;
</p>
<h3 class="typedef"><a id="mxml_strcopy_cb_t">mxml_strcopy_cb_t</a></h3>
<p class="description">String copy/allocation callback</p>
<p class="code">
typedef char *(*mxml_strcopy_cb_t)(void *cbdata const char *s);
</p>
<h3 class="typedef"><a id="mxml_strfree_cb_t">mxml_strfree_cb_t</a></h3>
<p class="description">String free callback</p>
<p class="code">
typedef void (*mxml_strfree_cb_t)(void *cbdata char *s);
</p>
<h3 class="typedef"><a id="mxml_type_cb_t">mxml_type_cb_t</a></h3>
<p class="description">Type callback function</p>
<p class="code">
typedef <a href="#mxml_type_t">mxml_type_t</a> (*mxml_type_cb_t)(void *cbdata <a href="#mxml_node_t">mxml_node_t</a> *node);
</p>
<h3 class="typedef"><a id="mxml_type_t">mxml_type_t</a></h3>
<p class="description">The XML node type.</p>
<p class="code">
typedef enum <a href="#mxml_type_e">mxml_type_e</a> mxml_type_t;
</p>
<h3 class="typedef"><a id="mxml_ws_cb_t">mxml_ws_cb_t</a></h3>
<p class="description">Whitespace callback function</p>
<p class="code">
typedef const char *(*mxml_ws_cb_t)(void *cbdata <a href="#mxml_node_t">mxml_node_t</a> *node <a href="#mxml_ws_t">mxml_ws_t</a> when);
</p>
<h3 class="typedef"><a id="mxml_ws_t">mxml_ws_t</a></h3>
<p class="description">Whitespace periods</p>
<p class="code">
typedef enum <a href="#mxml_ws_e">mxml_ws_e</a> mxml_ws_t;
</p>
<h2 class="title"><a id="ENUMERATIONS">Constants</a></h2>
<h3 class="enumeration"><a id="mxml_add_e">mxml_add_e</a></h3>
<p class="description"><a href="#mxmlAdd"><code>mxmlAdd</code></a> add values</p>
<h4 class="constants">Constants</h4>
<table class="list"><tbody>
<tr><th>MXML_ADD_AFTER </th><td class="description">Add node after specified node</td></tr>
<tr><th>MXML_ADD_BEFORE </th><td class="description">Add node before specified node</td></tr>
</tbody></table>
<h3 class="enumeration"><a id="mxml_descend_e">mxml_descend_e</a></h3>
<p class="description"><a href="#mxmlFindElement"><code>mxmlFindElement</code></a>, <a href="#mxmlWalkNext"><code>mxmlWalkNext</code></a>, and <a href="#mxmlWalkPrev"><code>mxmlWalkPrev</code></a> descend values</p>
<h4 class="constants">Constants</h4>
<table class="list"><tbody>
<tr><th>MXML_DESCEND_ALL </th><td class="description">Descend when finding/walking</td></tr>
<tr><th>MXML_DESCEND_FIRST </th><td class="description">Descend for first find</td></tr>
<tr><th>MXML_DESCEND_NONE </th><td class="description">Don't descend when finding/walking</td></tr>
</tbody></table>
<h3 class="enumeration"><a id="mxml_sax_event_e">mxml_sax_event_e</a></h3>
<p class="description">SAX event type.</p>
<h4 class="constants">Constants</h4>
<table class="list"><tbody>
<tr><th>MXML_SAX_EVENT_CDATA </th><td class="description">CDATA node</td></tr>
<tr><th>MXML_SAX_EVENT_COMMENT </th><td class="description">Comment node</td></tr>
<tr><th>MXML_SAX_EVENT_DATA </th><td class="description">Data node</td></tr>
<tr><th>MXML_SAX_EVENT_DECLARATION </th><td class="description">Declaration node</td></tr>
<tr><th>MXML_SAX_EVENT_DIRECTIVE </th><td class="description">Processing instruction node</td></tr>
<tr><th>MXML_SAX_EVENT_ELEMENT_CLOSE </th><td class="description">Element closed</td></tr>
<tr><th>MXML_SAX_EVENT_ELEMENT_OPEN </th><td class="description">Element opened</td></tr>
</tbody></table>
<h3 class="enumeration"><a id="mxml_type_e">mxml_type_e</a></h3>
<p class="description">The XML node type.</p>
<h4 class="constants">Constants</h4>
<table class="list"><tbody>
<tr><th>MXML_TYPE_CDATA </th><td class="description">CDATA value (&quot;<a href="[CDATA[...]]">[CDATA[...]]</a>&quot;)</td></tr>
<tr><th>MXML_TYPE_COMMENT </th><td class="description">Comment (&quot;<a href="!--...--">!--...--</a>&quot;)</td></tr>
<tr><th>MXML_TYPE_CUSTOM </th><td class="description">Custom data</td></tr>
<tr><th>MXML_TYPE_DECLARATION </th><td class="description">Declaration (&quot;<a href="!...">!...</a>&quot;)</td></tr>
<tr><th>MXML_TYPE_DIRECTIVE </th><td class="description">Processing instruction (&quot;<a href="?...?">?...?</a>&quot;)</td></tr>
<tr><th>MXML_TYPE_ELEMENT </th><td class="description">XML element with attributes</td></tr>
<tr><th>MXML_TYPE_IGNORE </th><td class="description">Ignore/throw away node</td></tr>
<tr><th>MXML_TYPE_INTEGER </th><td class="description">Integer value</td></tr>
<tr><th>MXML_TYPE_OPAQUE </th><td class="description">Opaque string</td></tr>
<tr><th>MXML_TYPE_REAL </th><td class="description">Real value</td></tr>
<tr><th>MXML_TYPE_TEXT </th><td class="description">Text fragment</td></tr>
</tbody></table>
<h3 class="enumeration"><a id="mxml_ws_e">mxml_ws_e</a></h3>
<p class="description">Whitespace periods</p>
<h4 class="constants">Constants</h4>
<table class="list"><tbody>
<tr><th>MXML_WS_AFTER_CLOSE </th><td class="description">Callback for after close tag</td></tr>
<tr><th>MXML_WS_AFTER_OPEN </th><td class="description">Callback for after open tag</td></tr>
<tr><th>MXML_WS_BEFORE_CLOSE </th><td class="description">Callback for before close tag</td></tr>
<tr><th>MXML_WS_BEFORE_OPEN </th><td class="description">Callback for before open tag</td></tr>
</tbody></table>
</div>
</body>
</html>
